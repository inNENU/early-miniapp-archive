{"version":3,"sources":["wxpage.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["/*!\n * wxpage v1.1.9\n * https://github.com/tvfe/wxpage\n * License MIT\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 7);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n\nvar undef = void(0)\nfunction hasOwn (obj, prop) {\n\treturn obj && obj.hasOwnProperty && obj.hasOwnProperty(prop)\n}\nfunction _nextTick() {\n\t// global\n\tvar ctx = this\n\treturn function () {\n\t\treturn setTimeout.apply(ctx, arguments)\n\t}\n}\nvar fns = {\n\ttype: function(obj) {\n\t\tif (obj === null) return 'null'\n\t\telse if (obj === undef) return 'undefined'\n\t\tvar m = /\\[object (\\w+)\\]/.exec(Object.prototype.toString.call(obj))\n\t\treturn m ? m[1].toLowerCase() : ''\n\t},\n\textend: function(obj) {\n\t\tif (fns.type(obj) != 'object' && fns.type(obj) != 'function') return obj;\n\t\tvar source, prop;\n\t\tfor (var i = 1, length = arguments.length; i < length; i++) {\n\t\t\tsource = arguments[i];\n\t\t\tfor (prop in source) {\n\t\t\t\tif (hasOwn(source, prop)) {\n\t\t\t\t\tobj[prop] = source[prop];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn obj;\n\t},\n\tobjEach: function (obj, fn) {\n\t\tif (!obj) return\n\t\tfor(var key in obj) {\n\t\t\tif (hasOwn(obj, key)) {\n\t\t\t\tif(fn(key, obj[key]) === false) break\n\t\t\t}\n\t\t}\n\t},\n\tnextTick: _nextTick(),\n\t/**\n\t * Lock function before lock release\n\t */\n\tlock: function lock(fn) {\n\t\tvar pending\n\t\treturn function () {\n\t\t\tif (pending) return\n\t\t\tpending = true\n\t\t\tvar args = [].slice.call(arguments, 0)\n\t\t\targs.unshift(function () {\n\t\t\t\tpending = false\n\t\t\t})\n\t\t\treturn fn.apply(this, args)\n\t\t}\n\t},\n\t/**\n\t * Queue when pending, execute one by one\n\t * @param {Function} fn executed function\n\t * @param {Number} capacity Allow run how much parall task at once\n\t * @async\n\t */\n\tqueue: function queue(fn, capacity) {\n\t\tcapacity = capacity || 1\n\t\tvar callbacks = []\n\t\tvar remains = capacity\n\t\tfunction next() {\n\t\t\tvar item = callbacks.shift()\n\t\t\tif (!item) {\n\t\t\t\tremains = capacity\n\t\t\t\treturn\n\t\t\t}\n\t\t\tremains--\n\t\t\tvar fn = item[0]\n\t\t\tvar ctx = item[1]\n\t\t\tvar args = item[2]\n\t\t\targs.unshift(function () {\n\t\t\t\t// once task is done, remains increasing\n\t\t\t\tremains ++\n\t\t\t\t// then check or call next task\n\t\t\t\tnext.apply(this, arguments)\n\t\t\t})\n\t\t\tfns.nextTick(function () {\n\t\t\t\treturn fn.apply(ctx, args)\n\t\t\t})\n\t\t}\n\t\treturn function () {\n\t\t\tcallbacks.push([fn, this, [].slice.call(arguments, 0)])\n\t\t\tif (!remains) return\n\t\t\treturn next()\n\t\t}\n\t},\n\t/**\n\t * Queue and wait for the same result\n\t * @param {Function} delegate method\n\t * @return {Function} the method receive a callback function\n\t */\n\tdelegator: function (fn) {\n\t\tvar pending\n\t\tvar queue = []\n\t\treturn function (cb) {\n\t\t\tif (pending) return queue.push(cb)\n\t\t\tpending = true\n\t\t\tfn.call(this, function () {\n\t\t\t\tpending = false\n\t\t\t\tvar ctx = this\n\t\t\t\tvar args = arguments\n\t\t\t\tcb && cb.apply(ctx, args)\n\t\t\t\tqueue.forEach(function (f) {\n\t\t\t\t\tf && f.apply(ctx, args)\n\t\t\t\t})\n\t\t\t})\n\t\t}\n\t},\n\t/**\n\t * Call only once\n\t */\n\tonce: function (fn/*[, ctx]*/) {\n\t\tvar args = arguments\n\t\tvar called\n\t\treturn function () {\n\t\t\tif (called || !fn) return\n\t\t\tcalled = true\n\t\t\treturn fn.apply(args.length >=2 ? args[1] : null, arguments)\n\t\t}\n\t},\n\t/**\n\t *  解析 query 字符串\n\t **/\n\tqueryParse: function(search, spliter) {\n\t\tif (!search) return {};\n\n\t\tspliter = spliter || '&';\n\n\t\tvar query = search.replace(/^\\?/, ''),\n\t\t\tqueries = {},\n\t\t\tsplits = query ? query.split(spliter) : null;\n\n\t\tif (splits && splits.length > 0) {\n\t\t\tsplits.forEach(function(item) {\n\t\t\t\titem = item.split('=');\n\t\t\t\tvar key = item.splice(0, 1),\n\t\t\t\t\tvalue = item.join('=');\n\t\t\t\tqueries[key] = value;\n\t\t\t});\n\t\t}\n\t\treturn queries;\n\t},\n\t/**\n\t * URL添加query\n\t */\n\tqueryJoin: function (api, queries, unencoded) {\n\t\tvar qs = fns.queryStringify(queries, '&', unencoded)\n\t\tif (!qs) return api\n\n\t\tvar sep\n\t\tif (/[\\?&]$/.test(api)) {\n\t\t\tsep = ''\n\t\t} else if (~api.indexOf('?')) {\n\t\t\tsep = '&'\n\t\t} else {\n\t\t\tsep = '?'\n\t\t}\n\t\treturn api + sep + qs\n\t},\n\t/**\n\t * query 对象转换字符串\n\t */\n\tqueryStringify: function (params, spliter, unencoded) {\n\t\tif (!params) return ''\n\t\treturn Object.keys(params).map(function (k) {\n\t\t\tvar v = params[k]\n\t\t\treturn k + '=' + (unencoded ? v : encodeURIComponent(v))\n\t\t}).join(spliter || '&')\n\t},\n\twrapFun: function (pre, wrapper) {\n\t\treturn function () {\n\t\t\ttry {\n\t\t\t\twrapper && wrapper.apply(this, arguments)\n\t\t\t} finally{\n\t\t\t\tpre && pre.apply(this, arguments)\n\t\t\t}\n\t\t}\n\t}\n}\n\nmodule.exports = fns\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n\nvar fns = __webpack_require__(0)\nvar sessionId = +new Date()\nvar sessionKey = 'session_'\nconsole.log('[Session] Current ssid:', sessionId)\nvar cache = {\n\tsession: {\n\t\tset: function (k, v, asyncCB) {\n\t\t\treturn cache.set(sessionKey+k, v, -1*sessionId, asyncCB)\n\t\t},\n\t\tget: function (k, asyncCB) {\n\t\t\treturn cache.get(sessionKey+k, asyncCB)\n\t\t},\n\t\tremove: function (k, asyncCB) {\n\t\t\treturn cache.remove(sessionKey+k, asyncCB)\n\t\t}\n\t},\n\t/**\n\t * setter\n\t * @param {String} k      key\n\t * @param {Object} v      value\n\t * @param {Number} expire 过期时间，毫秒，为负数的时候表示为唯一session ID，为 true 表示保持上一次缓存时间\n\t * @param {Function} asyncCB optional, 是否异步、异步回调方法\n\t */\n\tset: function (k, v, expire, asyncCB) {\n\t\tif (fns.type(expire) == 'function') {\n\t\t\tasyncCB = expire\n\t\t\texpire = 0\n\t\t} else if (asyncCB && fns.type(asyncCB) != 'function') {\n\t\t\tasyncCB = noop\n\t\t}\n\t\tvar data = {\n\t\t\texpr: 0,\n\t\t\tdata: v\n\t\t}\n\t\tvar expireTime\n\t\t/**\n\t\t * 保持上次缓存时间\n\t\t */\n\t\tif (expire === true) {\n\t\t\tvar _cdata = wx.getStorageSync('_cache_' + k)\n\t\t\t// 上次没有缓存，本次也不更新\n\t\t\tif (!_cdata) return\n\t\t\t// 使用上次过期时间\n\t\t\tdata.expr = _cdata.expr || 0\n\t\t\texpireTime = 1\n\t\t}\n\t\tif (!expireTime) {\n\t\t\texpire = expire || 0\n\t\t\tif (expire > 0) {\n\t\t\t\tvar t = + new Date()\n\t\t\t\texpire = expire + t\n\t\t\t}\n\t\t\tdata.expr = +expire\n\t\t}\n\t\t/**\n\t\t * 根据异步方法决定同步、异步更新\n\t\t */\n\t\tif (asyncCB) {\n\t\t\twx.setStorage({\n\t\t\t\tkey: '_cache_' + k,\n\t\t\t\tdata: data,\n\t\t\t\tsuccess: function () {\n\t\t\t\t\tasyncCB()\n\t\t\t\t},\n\t\t\t\tfail: function (e) {\n\t\t\t\t\tasyncCB(e || `set \"${k}\" fail`)\n\t\t\t\t}\n\t\t\t})\n\t\t} else {\n\t\t\twx.setStorageSync('_cache_' + k, data)\n\t\t}\n\t},\n\t/**\n\t * getter\n\t * @param {String} k      key\n\t * @param {Function} asyncCB optional, 是否异步、异步回调方法\n\t */\n\tget: function (k, asyncCB) {\n\t\tif (asyncCB) {\n\t\t\tif (fns.type(asyncCB) != 'function') asyncCB = noop\n\t\t\tvar errMsg = `get \"${k}\" fail`\n\t\t\twx.getStorage({\n\t\t\t\tkey: '_cache_' + k,\n\t\t\t\tsuccess: function (data) {\n\t\t\t\t\tif (data && data.data) {\n\t\t\t\t\t\tasyncCB(null, _resolve(k, data.data))\n\t\t\t\t\t} else {\n\t\t\t\t\t\tasyncCB(data ? data.errMsg || errMsg : errMsg)\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tfail: function (e) {\n\t\t\t\t\tasyncCB(e || errMsg)\n\t\t\t\t}\n\t\t\t})\n\t\t} else {\n\t\t\treturn _resolve(k, wx.getStorageSync('_cache_' + k))\n\t\t}\n\t},\n\tremove: function (k, asyncCB) {\n\t\tif (asyncCB) {\n\t\t\tif (fns.type(asyncCB) != 'function') asyncCB = noop\n\t\t\tvar errMsg = `remove \"${k}\" fail`\n\t\t\twx.removeStorage({\n\t\t\t\tkey: '_cache_' + k,\n\t\t\t\tsuccess: function () {\n\t\t\t\t\tasyncCB(null, true)\n\t\t\t\t},\n\t\t\t\tfail: function (e) {\n\t\t\t\t\tasyncCB(e || errMsg)\n\t\t\t\t}\n\t\t\t})\n\t\t} else {\n\t\t\treturn _resolve(k, wx.removeStorageSync('_cache_' + k))\n\t\t}\n\t}\n}\nfunction _resolve(k, v) {\n\tif (!v) return null\n\t// 永久存储\n\tif (!v.expr) return v.data\n\telse {\n\t\tif (v.expr < 0 && -1*v.expr == sessionId) {\n\t\t\t// session\n\t\t \treturn v.data\n\t\t} else if (v.expr > 0 && new Date() < v.expr) {\n\t\t\t// 普通存储\n\t\t\treturn v.data\n\t\t} else {\n\t\t \twx.removeStorage({\n\t\t \t\tkey: k\n\t\t \t})\n\t\t\treturn null\n\t\t}\n\t}\n}\nfunction noop() {}\nmodule.exports = cache\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar fns = __webpack_require__(0)\nvar _conf = {\n\tnameResolve: function () {}\n}\nmodule.exports = {\n\tset: function (k, v) {\n\t\tswitch(k) {\n\t\t\tcase 'resolvePath':\n\t\t\t\tif (fns.type(v) == 'function') {\n\t\t\t\t\t_conf.customRouteResolve = v\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\tcase 'route':\n\t\t\t\tlet t = fns.type(v)\n\t\t\t\tif (t == 'string' || t == 'array') {\n\t\t\t\t\t\tlet routes = (t == 'string' ? [v]:v)\n\t\t\t\t\t\tlet mainRoute = routes[0]\n\t\t\t\t\t\troutes = routes.map(function (item) {\n\t\t\t\t\t\t\treturn new RegExp('^'+item\n\t\t\t\t\t\t\t\t.replace(/^\\/?/, '/?')\n\t\t\t\t\t\t\t\t.replace(/[\\.]/g, '\\\\.')\n\t\t\t\t\t\t\t\t.replace('$page', '([\\\\w\\\\-]+)')\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t})\n\t\t\t\t\t\t_conf.routeResolve = function (name) {\n\t\t\t\t\t\t\treturn mainRoute.replace('$page', name)\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_conf.nameResolve = function (url) {\n\t\t\t\t\t\t\tvar n = ''\n\t\t\t\t\t\t\troutes.some(function (reg) {\n\t\t\t\t\t\t\t\tvar m = reg.exec(url)\n\t\t\t\t\t\t\t\tif (m) {\n\t\t\t\t\t\t\t\t\tn = m[1]\n\t\t\t\t\t\t\t\t\treturn true\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\treturn n\n\t\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error('Illegal routes option:', v)\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\t_conf[k] = v\n\t\t}\n\t},\n\tget: function (k) {\n\t\treturn _conf[k]\n\t}\n}\n\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n/**\n *  Simple Pub/Sub module\n *  @tencent/message and 减掉fns依赖\n **/\n\n\nfunction Message() {\n\tthis._evtObjs = {};\n}\nMessage.prototype.on = function (evtType, handler, _once) {\n\tif (!this._evtObjs[evtType]) {\n\t\tthis._evtObjs[evtType] = [];\n\t}\n\tthis._evtObjs[evtType].push({\n\t\thandler: handler,\n\t\tonce: _once\n\t})\n\tvar that = this\n\treturn function () {\n\t\tthat.off(evtType, handler)\n\t}\n}\nMessage.prototype.off = function (evtType, handler) {\n\tvar types;\n\tif (evtType) {\n\t\ttypes = [evtType];\n\t} else {\n\t\ttypes = Object.keys(this._evtObjs)\n\t}\n\tvar that = this;\n\ttypes.forEach(function (type) {\n\t\tif (!handler) {\n\t\t\t// remove all\n\t\t\tthat._evtObjs[type] = [];\n\t\t} else {\n\t\t\tvar handlers = that._evtObjs[type] || [],\n\t\t\t\tnextHandlers = [];\n\n\t\t\thandlers.forEach(function (evtObj) {\n\t\t\t\tif (evtObj.handler !== handler) {\n\t\t\t\t\tnextHandlers.push(evtObj)\n\t\t\t\t}\n\t\t\t})\n\t\t\tthat._evtObjs[type] = nextHandlers;\n\t\t}\n\t})\n\n\treturn this;\n}\nMessage.prototype.emit = function (evtType) {\n\tvar args = Array.prototype.slice.call(arguments, 1)\n\n\tvar handlers = this._evtObjs[evtType] || [];\n\thandlers.forEach(function (evtObj) {\n\t\tif (evtObj.once && evtObj.called) return\n\t\tevtObj.called = true\n\t\ttry {\n\t\t\tevtObj.handler && evtObj.handler.apply(null, args);\n\t\t} catch(e) {\n\t\t\tconsole.error(e.stack || e.message || e)\n\t\t}\n\t})\n}\nMessage.prototype.assign = function (target) {\n\tvar msg = this;\n\t['on', 'off', 'emit', 'assign'].forEach(function (name) {\n\t\tvar method = msg[name]\n\t\ttarget[name] = function () {\n\t\t\treturn method.apply(msg, arguments)\n\t\t}\n\t})\n}\n/**\n *  Global Message Central\n **/\n;(new Message()).assign(Message)\nmodule.exports = Message;\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n/**\n * 对wx.navigateTo、wx.redirectTo、wx.navigateBack的包装，在它们的基础上添加了事件\n */\nvar Message = __webpack_require__(3)\nvar exportee = module.exports = new Message()\nvar timer, readyTimer, pending\n\nexportee.on('page:ready', function () {\n\treadyTimer = setTimeout(function () {\n\t\tpending = false\n\t}, 100)\n})\nfunction route(type, cfg, args) {\n\tif (pending) return\n\tpending = true\n\tclearTimeout(timer)\n\tclearTimeout(readyTimer)\n\t/**\n\t * 2s内避免重复的跳转\n\t */\n\ttimer = setTimeout(function () {\n\t\tpending = false\n\t}, 2000)\n\texportee.emit('navigateTo', cfg.url)\n\n\t// 会存在不兼容接口，例如：reLaunch\n\tif (wx[type]) {\n\t\treturn wx[type].apply(wx, args)\n\t}\n}\nexportee.navigateTo = function (cfg) {\n\treturn route('navigateTo', cfg, arguments)\n}\nexportee.redirectTo = function (cfg) {\n\treturn route('redirectTo', cfg, arguments)\n}\nexportee.switchTab = function (cfg) {\n\treturn route('switchTab', cfg, arguments)\n}\nexportee.reLaunch = function (cfg) {\n\treturn route('reLaunch', cfg, arguments)\n}\nexportee.navigateBack = function () {\n  return wx.navigateBack.apply(wx, arguments)\n}\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar cache = __webpack_require__(1)\nvar redirector = __webpack_require__(4)\nvar conf = __webpack_require__(2)\nvar fns = __webpack_require__(0)\nvar navigate = route({type: 'navigateTo'})\nvar redirect = route({type: 'redirectTo'})\nvar switchTab = route({type: 'switchTab'})\nvar reLaunch = route({type: 'reLaunch'})\nvar routeMethods = {navigate, redirect, switchTab, reLaunch}\nvar bindNavigate = clickDelegate('navigate')\nvar bindRedirect = clickDelegate('redirect')\nvar bindSwitch = clickDelegate('switchTab')\nvar bindReLaunch = clickDelegate('reLaunch')\nvar channel = {}\nvar dispatcher\nvar getRef\n\nmodule.exports = {\n\tchannel,\n\tdispatcher: function (d) {\n\t\tdispatcher = d\n\t},\n\tref: function (fn) {\n\t\tgetRef = fn\n\t},\n\tmount: function (e) {\n\t\tvar payload = e.detail\n\t\tswitch(payload.type) {\n\t\t\tcase 'attached':\n\t\t\t\tlet ref = getRef && getRef(payload.id)\n\t\t\t\tif (!ref) return\n\n\t\t\t\tlet refName = ref._$ref\n\t\t\t\tif (refName && this.$refs) {\n\t\t\t\t\tthis.$refs[refName] = ref\n\t\t\t\t}\n\t\t\t\tref._$attached(this)\n\t\t\t\tbreak\n\t\t\tcase 'event:call':\n\t\t\t\tlet method = this[payload.method]\n\t\t\t\tmethod && method.apply(this, payload.args)\n\t\t\tdefault:\n\t\t\t\tbreak\n\t\t}\n\t},\n\tredirectDelegate: function (emitter, dispatcher) {\n\t\t;['navigateTo', 'redirectTo', 'switchTab', 'reLaunch'].forEach(function (k) {\n\t\t\temitter.on(k, function (url) {\n\t\t\t\tvar name = getPageName(url)\n\t\t\t\tname && dispatcher.emit(k+':'+name, url, fns.queryParse(url.split('?')[1]))\n\t\t\t})\n\t\t})\n\t},\n\tmethods: function (ctx) {\n\t\t/**\n\t\t * 缓存\n\t\t */\n\t\tctx.$cache = cache\n\t\tctx.$session = cache.session\n\t\t/**\n\t\t * 存一次，取一次\n\t\t */\n\t\tctx.$put = put\n\t\t/**\n\t\t * 只能被取一次\n\t\t */\n\t\tctx.$take = take\n\t\t/**\n\t\t * 实例引用集合\n\t\t */\n\t\tctx.$refs = {}\n\n\t\t/**\n\t\t * 路由方法\n\t\t */\n\t\tctx.$route = ctx.$navigate = navigate\n\t\tctx.$redirect = redirect\n\t\tctx.$switch = switchTab\n\t\tctx.$launch = reLaunch\n\t\tctx.$back = back\n\t\t/**\n\t\t * 页面预加载\n\t\t */\n\t\tctx.$preload = preload\n\t\t/**\n\t\t * 点击跳转代理\n\t\t */\n\t\tctx.$bindRoute = ctx.$bindNavigate = bindNavigate\n\t\tctx.$bindRedirect = bindRedirect\n\t\tctx.$bindSwitch = bindSwitch\n\t\tctx.$bindReLaunch = bindReLaunch\n\t\t/**\n\t\t * 页面信息\n\t\t */\n\t\tctx.$curPage = getPage\n\t\tctx.$curPageName = curPageName\n\t},\n\tgetPageName\n}\n/**\n * Navigate handler\n */\nfunction route ({type}) {\n\t// url: $page[?name=value]\n\treturn function (url, config) {\n\t\tvar parts = url.split(/\\?/)\n\t\tvar pagepath = parts[0]\n\t\tif (/^[\\w\\-]+$/.test(pagepath)) {\n\t\t\tpagepath = (conf.get('customRouteResolve') || conf.get('routeResolve'))(pagepath)\n\t\t}\n\t\tif (!pagepath) {\n\t\t\tthrow new Error('Invalid path:', pagepath)\n\t\t}\n\t\tconfig = config || {}\n\t\t// append querystring\n\t\tconfig.url = pagepath + (parts[1] ? '?' + parts[1] : '')\n\t\tredirector[type](config)\n\t}\n}\n\nfunction clickDelegate(type) {\n\tvar _route = routeMethods[type]\n\treturn function (e) {\n\t\tif (!e) return\n\t\tvar dataset = e.currentTarget.dataset\n\t\tvar before = dataset.before\n\t\tvar after = dataset.after\n\t\tvar url = dataset.url\n\t\tvar ctx = this\n\t\ttry {\n\t\t\tif (ctx && before && ctx[before]) ctx[before].call(ctx, e)\n\t\t} finally {\n\t\t\tif (!url) return\n\t\t\t_route(url)\n\t\t\tif (ctx && after && ctx[after]) ctx[after].call(ctx, e)\n\t\t}\n\t}\n}\n\nfunction back(delta) {\n\twx.navigateBack({\n\t\tdelta: delta || 1\n\t})\n}\nfunction preload(url){\n\tvar name = getPageName(url)\n\tname && dispatcher && dispatcher.emit('preload:'+name, url, fns.queryParse(url.split('?')[1]))\n}\nfunction getPage() {\n\treturn getCurrentPages().slice(0).pop()\n}\nfunction getPageName(url) {\n\tvar m = /^[\\w\\-]+(?=\\?|$)/.exec(url)\n\treturn m ? m[0] : conf.get('nameResolve')(url)\n}\nfunction curPageName () {\n\tvar route = getPage().route\n\tif (!route) return ''\n\treturn getPageName(route)\n}\nfunction put (key, value) {\n\tchannel[key] = value\n\treturn this\n}\nfunction take (key) {\n\tvar v = channel[key]\n\t// 释放引用\n\tchannel[key] = null\n\treturn v\n}\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n\nvar fns = __webpack_require__(0)\nvar bridge = __webpack_require__(5)\nvar cache = __webpack_require__(1)\nvar conf = __webpack_require__(2)\nvar redirector = __webpack_require__(4)\nvar message = __webpack_require__(3)\nvar modules = {\n\tfns, redirector, cache, message, dispatcher,\n\tchannel: bridge.channel\n}\nvar dispatcher\n/**\n * Component constructor\n */\nvar refs = {}\nvar cid = 0\nfunction component(def) {\n\tif (!def) {\n\t\tconsole.error(`Illegal component options.`)\n\t\tdef = {}\n\t}\n\t// extend page config\n\tvar extendComponentBefore = conf.get('extendComponentBefore')\n\textendComponentBefore && extendComponentBefore(def, modules)\n\n\tdef.created = fns.wrapFun(def.created, function () {\n\t\tbridge.methods(this, dispatcher)\n\t})\n\tdef.attached = fns.wrapFun(def.attached, function () {\n\t\tvar id = ++cid\n\t\tthis.$id = id\n\t\trefs[id] = this\n\t\tthis._$ref = this.properties.ref || this.properties._ref\n\t\tthis.triggerEvent('ing', {\n\t\t\tid: this.$id,\n\t\t\ttype: 'attached'\n\t\t})\n\t})\n\tdef.detached = fns.wrapFun(def.detached, function () {\n\t\tdelete refs[this.$id]\n\t\tvar $refs = this.$parent && this.$parent.$refs\n\t\tvar refName = this._$ref\n\t\tif (refName && $refs) {\n\t\t\tdelete $refs[refName]\n\t\t}\n\t\tthis.$parent = null\n\t})\n\tdef.properties = fns.extend({}, def.properties, {\n    'ref': {\n    \ttype: String,\n      value: '',\n      observer: function(next) {\n      \t/**\n      \t * 支持动态 ref\n      \t */\n      \tif (this._$ref !== next) {\n\t\t\t\t\tvar $refs = this.$parent && this.$parent.$refs\n\t\t\t\t\tif ($refs) {\n\t\t\t\t\t\tlet ref = $refs[this._$ref]\n\t\t\t\t\t\tdelete $refs[this._$ref]\n\t\t\t\t\t\tthis._$ref = next\n\t\t\t\t\t\tif (ref && next) {\n\t\t\t\t\t\t\t$refs[next]\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n      \t}\n      }\n    },\n\t})\n\tdef.methods = fns.extend({}, def.methods, {\n\t\t// 与旧的一致\n\t\t$set: function () {\n\t\t\treturn this.setData.apply(this, arguments)\n\t\t},\n\t\t$data: function () {\n\t\t\treturn this.data\n\t\t},\n\t\t$emit: function () {\n\t\t\tif (!dispatcher) return\n\t\t\treturn dispatcher.emit.apply(dispatcher, arguments)\n\t\t},\n\t\t$on: function () {\n\t\t\tif (!dispatcher) return function () {}\n\t\t\treturn dispatcher.on.apply(dispatcher, arguments)\n\t\t},\n\t\t$off: function () {\n\t\t\tif (!dispatcher) return\n\t\t\treturn dispatcher.off.apply(dispatcher, arguments)\n\t\t},\n\t\t$call: function (method) {\n\t\t\tvar args = [].slice.call(arguments, 1)\n\t\t\tthis.triggerEvent('ing', {\n\t\t\t\tid: this.$id,\n\t\t\t\ttype: 'event:call',\n\t\t\t\tmethod,\n\t\t\t\targs\n\t\t\t})\n\t\t},\n\t\t/**\n\t\t * 由父组件调用\n\t\t */\n\t\t_$attached: function (parent) {\n\t\t\tthis.$root = parent.$root || parent\n\t\t\tthis.$parent = parent\n\t\t},\n\t\t$: bridge.mount\n\t})\n\tComponent(def)\n}\ncomponent.getRef = function (id) {\n\treturn refs[id]\n}\nbridge.ref(component.getRef)\ncomponent.dispatcher = function (d) {\n\tdispatcher = d\n}\nComponent.C = component\nmodule.exports = component\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n\n\nvar fns = __webpack_require__(0)\nvar message = __webpack_require__(3)\nvar redirector = __webpack_require__(4)\nvar cache = __webpack_require__(1)\nvar C = __webpack_require__(6)\nvar bridge = __webpack_require__(5)\nvar _conf = __webpack_require__(2)\nvar dispatcher = new message()\nvar hasPageLoaded = 0\nvar isAppLaunched = 0\nvar isAppShowed = 0\nvar hideTime = 0\nvar modules = {\n\tfns, redirector, cache, message, dispatcher,\n\tchannel: bridge.channel\n}\nbridge.ref(C.getRef)\nbridge.dispatcher(dispatcher)\nC.dispatcher(dispatcher)\nfunction WXPage(name, option) {\n\tif (fns.type(name) == 'object') {\n\t\toption = name\n\t\tname = option.name || '_unknow'\n\t}\n\t// page internal message\n\tvar emitter = new message()\n\n\t// extend page config\n\tvar extendPageBefore = _conf.get('extendPageBefore')\n\textendPageBefore && extendPageBefore(name, option, modules)\n\n\t// mixin component defs\n\t// C.use(option, option.comps, `Page[${name}]`, emitter)\n\tif (option.onNavigate){\n\t\tlet onNavigateHandler = function (url, query) {\n\t\t\toption.onNavigate({url, query})\n\t\t}\n\t\tconsole.log(`Page[${name}] define \"onNavigate\".`)\n\t\tdispatcher.on('navigateTo:'+name, onNavigateHandler)\n\t\tdispatcher.on('redirectTo:'+name, onNavigateHandler)\n\t\tdispatcher.on('switchTab:'+name, onNavigateHandler)\n\t\tdispatcher.on('reLaunch:'+name, onNavigateHandler)\n\t}\n\t/**\n\t * Preload lifecycle method\n\t */\n\tif (option.onPreload){\n\t\tconsole.log(`Page[${name}] define \"onPreload\".`)\n\t\tdispatcher.on('preload:'+name, function (url, query) {\n\t\t\toption.onPreload({url, query})\n\t\t})\n\t}\n\t/**\n\t * Instance props\n\t */\n\toption.$state = {\n\t\t// 是否小程序被打开首页启动页面\n\t\tfirstOpen: false\n\t}\n\toption.$emitter = emitter\n\tbridge.methods(option)\n\n\t/**\n\t * Cross pages message methods\n\t */\n\toption.$on = function () {\n\t\treturn dispatcher.on.apply(dispatcher, arguments)\n\t}\n\toption.$emit = function () {\n\t\treturn dispatcher.emit.apply(dispatcher, arguments)\n\t}\n\toption.$off = function () {\n\t\treturn dispatcher.off.apply(dispatcher, arguments)\n\t}\n\t/**\n\t * 父子通信枢纽模块\n\t */\n\toption.$ = bridge.mount\n\t/**\n\t * setData wrapper, for component setData with prefix\n\t * @param {String} prefix prefix of component's data\n\t * @param {Object} data\n\t */\n\toption.$setData = function (prefix, data) {\n\t\tif (fns.type(prefix) == 'string') {\n\t\t\tvar props = {}\n\t\t\tfns.objEach(data, function (k,v) {\n\t\t\t\tprops[prefix + '.' + k] = v\n\t\t\t})\n\t\t\treturn this.setData(props)\n\t\t} else if (fns.type(prefix) == 'object') {\n\t\t\treturn this.setData(prefix)\n\t\t}\n\t}\n\t/**\n\t * AOP life-cycle methods hook\n\t */\n\toption.onLoad = fns.wrapFun(option.onLoad, function() {\n\t\t// After onLoad, onAwake is valid if defined\n\t\toption.onAwake && message.on('app:sleep', (t) => {\n\t\t\toption.onAwake.call(this, t)\n\t\t})\n\t\tif (!hasPageLoaded) {\n\t\t\thasPageLoaded = true\n\n\t\t\tlet $state = this.$state\n\t\t\t$state.firstOpen = true\n\t\t}\n\t})\n\toption.onReady = fns.wrapFun(option.onReady, function () {\n\t\tredirector.emit('page:ready')\n\t})\n\n\t// call on launch\n\tif (option.onPageLaunch) {\n\t\toption.onPageLaunch()\n\t}\n\tif (option.onAppLaunch) {\n\t\tisAppLaunched ? option.onAppLaunch.apply(option, isAppLaunched) : dispatcher.on('app:launch', function (args) {\n\t\t\toption.onAppLaunch.apply(option, args)\n\t\t})\n\t}\n\tif (option.onAppShow) {\n\t\tisAppLaunched ? option.onAppShow.apply(option, isAppLaunched) : dispatcher.on('app:show', function (args) {\n\t\t\toption.onAppShow.apply(option, args)\n\t\t})\n\t}\n\n\t// extend page config\n\tvar extendPageAfter = _conf.get('extendPageAfter')\n\textendPageAfter && extendPageAfter(name, option, modules)\n\t// register page\n\tPage(option)\n\treturn option;\n}\n/**\n * 由重定向模块转发到页面内派发器\n */\nbridge.redirectDelegate(redirector, dispatcher)\n/**\n * Application wrapper\n */\nfunction Application (option) {\n\n\tif (!option.config || !option.config.route || !option.config.route.length) {\n\t\tthrow new Error('config.route is necessary !')\n\t}\n\tif (option.config) {\n\t\tWXPage.config(option.config)\n\t}\n\tvar ctx = option\n\t/**\n\t * APP sleep logical\n\t */\n\toption.onShow = option.onShow ? fns.wrapFun(option.onShow, appShowHandler) : appShowHandler\n\toption.onHide = option.onHide ? fns.wrapFun(option.onHide, appHideHandler) : appHideHandler\n\toption.onLaunch = option.onLaunch ? fns.wrapFun(option.onLaunch, appLaunchHandler) : appLaunchHandler\n\toption.onLaunch = fns.wrapFun(option.onLaunch, function () {\n\t\tctx = this\n\t})\n\tif (option.onAwake) {\n\t\tmessage.on('app:sleep', function(t){\n\t\t\toption.onAwake.call(ctx, t)\n\t\t})\n\t}\n\t/**\n\t * Use app config\n\t */\n\tApp(option)\n}\nfunction appLaunchHandler() {\n\tisAppLaunched = [].slice.call(arguments)\n\tmessage.emit('app:launch', isAppLaunched)\n}\nfunction appShowHandler () {\n\ttry {\n\t\tif (!isAppShowed) {\n\t\t\t// call onAppShow only once\n\t\t\tisAppShowed = [].slice.call(arguments)\n\t\t\tmessage.emit('app:show', isAppShowed)\n\t\t}\n\t} finally {\n\t\tif (!hideTime) return\n\t\tvar t = hideTime\n\t\thideTime = 0\n\t\tmessage.emit('app:sleep', new Date() - t)\n\t}\n}\nfunction appHideHandler() {\n\thideTime = new Date()\n}\n\nPage.P = WXPage\nPage.C = Component.C = WXPage.C = WXPage.Comp = WXPage.Component = C\nPage.A = App.A = WXPage.A = WXPage.App = WXPage.Application = Application\nWXPage.redirector = redirector\nWXPage.message = message\nWXPage.cache = cache\nWXPage.fns = fns\nWXPage.getPageName = bridge.getPageName\n\n/**\n * Config handler\n */\n\nWXPage.config = function (key, value) {\n\tif (fns.type(key) == 'object') {\n\t\tfns.objEach(key, function (k, v) {\n\t\t\t_conf.set(k, v)\n\t\t})\n\t} else {\n\t\t_conf.set(key, value)\n\t}\n\treturn this\n}\nmessage.assign(WXPage)\nmessage.assign(C)\nmessage.assign(Application)\n/* harmony default export */ __webpack_exports__[\"default\"] = (WXPage);\n\n\n/***/ })\n/******/ ]);\n});\n"]}