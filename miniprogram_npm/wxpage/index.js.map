{"version":3,"sources":["wxpage.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["/*!\n * wxpage v1.1.9\n * https://github.com/tvfe/wxpage\n * License MIT\n */\nmodule.exports =\n/******/ (function (modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif (installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n        /******/\n}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n        /******/\n};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n      /******/\n}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function (value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function (exports, name, getter) {\n/******/ \t\tif (!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n  /******/\n});\n        /******/\n}\n      /******/\n};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function (module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n      /******/\n};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function (object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 7);\n    /******/\n})\n/************************************************************************/\n/******/([\n/* 0 */\n/***/ (function (module, exports, __webpack_require__) {\n\n    \n\n\n    var undef = void (0)\n    function hasOwn(obj, prop) {\n      return obj && obj.hasOwnProperty && obj.hasOwnProperty(prop)\n    }\n    function _nextTick() {\n      // global\n      var ctx = this\n      return function () {\n        return setTimeout.apply(ctx, arguments)\n      }\n    }\n    var fns = {\n      type: function (obj) {\n        if (obj === null) return 'null'\n        else if (obj === undef) return 'undefined'\n        var m = /\\[object (\\w+)\\]/.exec(Object.prototype.toString.call(obj))\n        return m ? m[1].toLowerCase() : ''\n      },\n      extend: function (obj) {\n        if (fns.type(obj) != 'object' && fns.type(obj) != 'function') return obj;\n        var source, prop;\n        for (var i = 1, length = arguments.length; i < length; i++) {\n          source = arguments[i];\n          for (prop in source) {\n            if (hasOwn(source, prop)) {\n              obj[prop] = source[prop];\n            }\n          }\n        }\n        return obj;\n      },\n      objEach: function (obj, fn) {\n        if (!obj) return\n        for (var key in obj) {\n          if (hasOwn(obj, key)) {\n            if (fn(key, obj[key]) === false) break\n          }\n        }\n      },\n      nextTick: _nextTick(),\n      /**\n       * Lock function before lock release\n       */\n      lock: function lock(fn) {\n        var pending\n        return function () {\n          if (pending) return\n          pending = true\n          var args = [].slice.call(arguments, 0)\n          args.unshift(function () {\n            pending = false\n          })\n          return fn.apply(this, args)\n        }\n      },\n      /**\n       * Queue when pending, execute one by one\n       * @param {Function} fn executed function\n       * @param {Number} capacity Allow run how much parall task at once\n       * @async\n       */\n      queue: function queue(fn, capacity) {\n        capacity = capacity || 1\n        var callbacks = []\n        var remains = capacity\n        function next() {\n          var item = callbacks.shift()\n          if (!item) {\n            remains = capacity\n            return\n          }\n          remains--\n          var fn = item[0]\n          var ctx = item[1]\n          var args = item[2]\n          args.unshift(function () {\n            // once task is done, remains increasing\n            remains++\n            // then check or call next task\n            next.apply(this, arguments)\n          })\n          fns.nextTick(function () {\n            return fn.apply(ctx, args)\n          })\n        }\n        return function () {\n          callbacks.push([fn, this, [].slice.call(arguments, 0)])\n          if (!remains) return\n          return next()\n        }\n      },\n      /**\n       * Queue and wait for the same result\n       * @param {Function} delegate method\n       * @return {Function} the method receive a callback function\n       */\n      delegator: function (fn) {\n        var pending\n        var queue = []\n        return function (cb) {\n          if (pending) return queue.push(cb)\n          pending = true\n          fn.call(this, function () {\n            pending = false\n            var ctx = this\n            var args = arguments\n            cb && cb.apply(ctx, args)\n            queue.forEach(function (f) {\n              f && f.apply(ctx, args)\n            })\n          })\n        }\n      },\n      /**\n       * Call only once\n       */\n      once: function (fn/*[, ctx]*/) {\n        var args = arguments\n        var called\n        return function () {\n          if (called || !fn) return\n          called = true\n          return fn.apply(args.length >= 2 ? args[1] : null, arguments)\n        }\n      },\n      /**\n       *  解析 query 字符串\n       **/\n      queryParse: function (search, spliter) {\n        if (!search) return {};\n\n        spliter = spliter || '&';\n\n        var query = search.replace(/^\\?/, ''),\n          queries = {},\n          splits = query ? query.split(spliter) : null;\n\n        if (splits && splits.length > 0) {\n          splits.forEach(function (item) {\n            item = item.split('=');\n            var key = item.splice(0, 1),\n              value = item.join('=');\n            queries[key] = value;\n          });\n        }\n        return queries;\n      },\n      /**\n       * URL添加query\n       */\n      queryJoin: function (api, queries, unencoded) {\n        var qs = fns.queryStringify(queries, '&', unencoded)\n        if (!qs) return api\n\n        var sep\n        if (/[\\?&]$/.test(api)) {\n          sep = ''\n        } else if (~api.indexOf('?')) {\n          sep = '&'\n        } else {\n          sep = '?'\n        }\n        return api + sep + qs\n      },\n      /**\n       * query 对象转换字符串\n       */\n      queryStringify: function (params, spliter, unencoded) {\n        if (!params) return ''\n        return Object.keys(params).map(function (k) {\n          var v = params[k]\n          return k + '=' + (unencoded ? v : encodeURIComponent(v))\n        }).join(spliter || '&')\n      },\n      wrapFun: function (pre, wrapper) {\n        return function () {\n          try {\n            wrapper && wrapper.apply(this, arguments)\n          } finally {\n            pre && pre.apply(this, arguments)\n          }\n        }\n      }\n    }\n\n    module.exports = fns\n\n\n    /***/\n}),\n/* 1 */\n/***/ (function (module, exports, __webpack_require__) {\n\n    \n\n\n    var fns = __webpack_require__(0)\n    var sessionId = +new Date()\n    var sessionKey = 'session_'\n    console.log('[Session] Current ssid:', sessionId)\n    var cache = {\n      session: {\n        set: function (k, v, asyncCB) {\n          return cache.set(sessionKey + k, v, -1 * sessionId, asyncCB)\n        },\n        get: function (k, asyncCB) {\n          return cache.get(sessionKey + k, asyncCB)\n        },\n        remove: function (k, asyncCB) {\n          return cache.remove(sessionKey + k, asyncCB)\n        }\n      },\n      /**\n       * setter\n       * @param {String} k      key\n       * @param {Object} v      value\n       * @param {Number} expire 过期时间，毫秒，为负数的时候表示为唯一session ID，为 true 表示保持上一次缓存时间\n       * @param {Function} asyncCB optional, 是否异步、异步回调方法\n       */\n      set: function (k, v, expire, asyncCB) {\n        if (fns.type(expire) == 'function') {\n          asyncCB = expire\n          expire = 0\n        } else if (asyncCB && fns.type(asyncCB) != 'function') {\n          asyncCB = noop\n        }\n        var data = {\n          expr: 0,\n          data: v\n        }\n        var expireTime\n        /**\n         * 保持上次缓存时间\n         */\n        if (expire === true) {\n          var _cdata = wx.getStorageSync('_cache_' + k)\n          // 上次没有缓存，本次也不更新\n          if (!_cdata) return\n          // 使用上次过期时间\n          data.expr = _cdata.expr || 0\n          expireTime = 1\n        }\n        if (!expireTime) {\n          expire = expire || 0\n          if (expire > 0) {\n            var t = + new Date()\n            expire = expire + t\n          }\n          data.expr = +expire\n        }\n        /**\n         * 根据异步方法决定同步、异步更新\n         */\n        if (asyncCB) {\n          wx.setStorage({\n            key: '_cache_' + k,\n            data: data,\n            success: function () {\n              asyncCB()\n            },\n            fail: function (e) {\n              asyncCB(e || `set \"${k}\" fail`)\n            }\n          })\n        } else {\n          wx.setStorageSync('_cache_' + k, data)\n        }\n      },\n      /**\n       * getter\n       * @param {String} k      key\n       * @param {Function} asyncCB optional, 是否异步、异步回调方法\n       */\n      get: function (k, asyncCB) {\n        if (asyncCB) {\n          if (fns.type(asyncCB) != 'function') asyncCB = noop\n          var errMsg = `get \"${k}\" fail`\n          wx.getStorage({\n            key: '_cache_' + k,\n            success: function (data) {\n              if (data && data.data) {\n                asyncCB(null, _resolve(k, data.data))\n              } else {\n                asyncCB(data ? data.errMsg || errMsg : errMsg)\n              }\n            },\n            fail: function (e) {\n              asyncCB(e || errMsg)\n            }\n          })\n        } else {\n          return _resolve(k, wx.getStorageSync('_cache_' + k))\n        }\n      },\n      remove: function (k, asyncCB) {\n        if (asyncCB) {\n          if (fns.type(asyncCB) != 'function') asyncCB = noop\n          var errMsg = `remove \"${k}\" fail`\n          wx.removeStorage({\n            key: '_cache_' + k,\n            success: function () {\n              asyncCB(null, true)\n            },\n            fail: function (e) {\n              asyncCB(e || errMsg)\n            }\n          })\n        } else {\n          return _resolve(k, wx.removeStorageSync('_cache_' + k))\n        }\n      }\n    }\n    function _resolve(k, v) {\n      if (!v) return null\n      // 永久存储\n      if (!v.expr) return v.data\n      else {\n        if (v.expr < 0 && -1 * v.expr == sessionId) {\n          // session\n          return v.data\n        } else if (v.expr > 0 && new Date() < v.expr) {\n          // 普通存储\n          return v.data\n        } else {\n          wx.removeStorage({\n            key: k\n          })\n          return null\n        }\n      }\n    }\n    function noop() { }\n    module.exports = cache\n\n\n    /***/\n}),\n/* 2 */\n/***/ (function (module, exports, __webpack_require__) {\n\n    var fns = __webpack_require__(0)\n    var _conf = {\n      nameResolve: function () { }\n    }\n    module.exports = {\n      set: function (k, v) {\n        switch (k) {\n          case 'resolvePath':\n            if (fns.type(v) == 'function') {\n              _conf.customRouteResolve = v\n            }\n            break\n          case 'route':\n            let t = fns.type(v)\n            if (t == 'string' || t == 'array') {\n              let routes = (t == 'string' ? [v] : v)\n              let mainRoute = routes[0]\n              routes = routes.map(function (item) {\n                return new RegExp('^' + item\n                  .replace(/^\\/?/, '/?')\n                  .replace(/[\\.]/g, '\\\\.')\n                  .replace('$page', '([\\\\w\\\\-]+)')\n                )\n              })\n              _conf.routeResolve = function (name) {\n                return mainRoute.replace('$page', name)\n              }\n              _conf.nameResolve = function (url) {\n                var n = ''\n                routes.some(function (reg) {\n                  var m = reg.exec(url)\n                  if (m) {\n                    n = m[1]\n                    return true\n                  }\n                })\n                return n\n              }\n\n            } else {\n              console.error('Illegal routes option:', v)\n            }\n            break\n          default:\n            _conf[k] = v\n        }\n      },\n      get: function (k) {\n        return _conf[k]\n      }\n    }\n\n\n\n    /***/\n}),\n/* 3 */\n/***/ (function (module, exports, __webpack_require__) {\n\n    \n    /**\n     *  Simple Pub/Sub module\n     *  @tencent/message and 减掉fns依赖\n     **/\n\n\n    function Message() {\n      this._evtObjs = {};\n    }\n    Message.prototype.on = function (evtType, handler, _once) {\n      if (!this._evtObjs[evtType]) {\n        this._evtObjs[evtType] = [];\n      }\n      this._evtObjs[evtType].push({\n        handler: handler,\n        once: _once\n      })\n      var that = this\n      return function () {\n        that.off(evtType, handler)\n      }\n    }\n    Message.prototype.off = function (evtType, handler) {\n      var types;\n      if (evtType) {\n        types = [evtType];\n      } else {\n        types = Object.keys(this._evtObjs)\n      }\n      var that = this;\n      types.forEach(function (type) {\n        if (!handler) {\n          // remove all\n          that._evtObjs[type] = [];\n        } else {\n          var handlers = that._evtObjs[type] || [],\n            nextHandlers = [];\n\n          handlers.forEach(function (evtObj) {\n            if (evtObj.handler !== handler) {\n              nextHandlers.push(evtObj)\n            }\n          })\n          that._evtObjs[type] = nextHandlers;\n        }\n      })\n\n      return this;\n    }\n    Message.prototype.emit = function (evtType) {\n      var args = Array.prototype.slice.call(arguments, 1)\n\n      var handlers = this._evtObjs[evtType] || [];\n      handlers.forEach(function (evtObj) {\n        if (evtObj.once && evtObj.called) return\n        evtObj.called = true\n        try {\n          evtObj.handler && evtObj.handler.apply(null, args);\n        } catch (e) {\n          console.error(e.stack || e.message || e)\n        }\n      })\n    }\n    Message.prototype.assign = function (target) {\n      var msg = this;\n      ['on', 'off', 'emit', 'assign'].forEach(function (name) {\n        var method = msg[name]\n        target[name] = function () {\n          return method.apply(msg, arguments)\n        }\n      })\n    }\n      /**\n       *  Global Message Central\n       **/\n      ; (new Message()).assign(Message)\n    module.exports = Message;\n\n\n    /***/\n}),\n/* 4 */\n/***/ (function (module, exports, __webpack_require__) {\n\n    \n\n    /**\n     * 对wx.navigateTo、wx.redirectTo、wx.navigateBack的包装，在它们的基础上添加了事件\n     */\n    var Message = __webpack_require__(3)\n    var exportee = module.exports = new Message()\n    var timer, readyTimer, pending\n\n    exportee.on('page:ready', function () {\n      readyTimer = setTimeout(function () {\n        pending = false\n      }, 100)\n    })\n    function route(type, cfg, args) {\n      if (pending) return\n      pending = true\n      clearTimeout(timer)\n      clearTimeout(readyTimer)\n      /**\n       * 2s内避免重复的跳转\n       */\n      timer = setTimeout(function () {\n        pending = false\n      }, 2000)\n      exportee.emit('navigateTo', cfg.url)\n\n      // 会存在不兼容接口，例如：reLaunch\n      if (wx[type]) {\n        return wx[type].apply(wx, args)\n      }\n    }\n    exportee.navigateTo = function (cfg) {\n      return route('navigateTo', cfg, arguments)\n    }\n    exportee.redirectTo = function (cfg) {\n      return route('redirectTo', cfg, arguments)\n    }\n    exportee.switchTab = function (cfg) {\n      return route('switchTab', cfg, arguments)\n    }\n    exportee.reLaunch = function (cfg) {\n      return route('reLaunch', cfg, arguments)\n    }\n    exportee.navigateBack = function () {\n      return wx.navigateBack.apply(wx, arguments)\n    }\n\n\n    /***/\n}),\n/* 5 */\n/***/ (function (module, exports, __webpack_require__) {\n\n    var cache = __webpack_require__(1)\n    var redirector = __webpack_require__(4)\n    var conf = __webpack_require__(2)\n    var fns = __webpack_require__(0)\n    var navigate = route({ type: 'navigateTo' })\n    var redirect = route({ type: 'redirectTo' })\n    var switchTab = route({ type: 'switchTab' })\n    var reLaunch = route({ type: 'reLaunch' })\n    var routeMethods = { navigate, redirect, switchTab, reLaunch }\n    var bindNavigate = clickDelegate('navigate')\n    var bindRedirect = clickDelegate('redirect')\n    var bindSwitch = clickDelegate('switchTab')\n    var bindReLaunch = clickDelegate('reLaunch')\n    var channel = {}\n    var dispatcher\n    var getRef\n\n    module.exports = {\n      channel,\n      dispatcher: function (d) {\n        dispatcher = d\n      },\n      ref: function (fn) {\n        getRef = fn\n      },\n      mount: function (e) {\n        var payload = e.detail\n        switch (payload.type) {\n          case 'attached':\n            let ref = getRef && getRef(payload.id)\n            if (!ref) return\n\n            let refName = ref._$ref\n            if (refName && this.$refs) {\n              this.$refs[refName] = ref\n            }\n            ref._$attached(this)\n            break\n          case 'event:call':\n            let method = this[payload.method]\n            method && method.apply(this, payload.args)\n          default:\n            break\n        }\n      },\n      redirectDelegate: function (emitter, dispatcher) {\n        ;['navigateTo', 'redirectTo', 'switchTab', 'reLaunch'].forEach(function (k) {\n          emitter.on(k, function (url) {\n            var name = getPageName(url)\n            name && dispatcher.emit(k + ':' + name, url, fns.queryParse(url.split('?')[1]))\n          })\n        })\n      },\n      methods: function (ctx) {\n        /**\n         * 缓存\n         */\n        ctx.$cache = cache\n        ctx.$session = cache.session\n        /**\n         * 存一次，取一次\n         */\n        ctx.$put = put\n        /**\n         * 只能被取一次\n         */\n        ctx.$take = take\n        /**\n         * 实例引用集合\n         */\n        ctx.$refs = {}\n\n        /**\n         * 路由方法\n         */\n        ctx.$route = ctx.$navigate = navigate\n        ctx.$redirect = redirect\n        ctx.$switch = switchTab\n        ctx.$launch = reLaunch\n        ctx.$back = back\n        /**\n         * 页面预加载\n         */\n        ctx.$preload = preload\n        /**\n         * 点击跳转代理\n         */\n        ctx.$bindRoute = ctx.$bindNavigate = bindNavigate\n        ctx.$bindRedirect = bindRedirect\n        ctx.$bindSwitch = bindSwitch\n        ctx.$bindReLaunch = bindReLaunch\n        /**\n         * 页面信息\n         */\n        ctx.$curPage = getPage\n        ctx.$curPageName = curPageName\n      },\n      getPageName\n    }\n    /**\n     * Navigate handler\n     */\n    function route({ type }) {\n      // url: $page[?name=value]\n      return function (url, config) {\n        var parts = url.split(/\\?/)\n        var pagepath = parts[0]\n        if (/^[\\w\\-]+$/.test(pagepath)) {\n          pagepath = (conf.get('customRouteResolve') || conf.get('routeResolve'))(pagepath)\n        }\n        if (!pagepath) {\n          throw new Error('Invalid path:', pagepath)\n        }\n        config = config || {}\n        // append querystring\n        config.url = pagepath + (parts[1] ? '?' + parts[1] : '')\n        redirector[type](config)\n      }\n    }\n\n    function clickDelegate(type) {\n      var _route = routeMethods[type]\n      return function (e) {\n        if (!e) return\n        var dataset = e.currentTarget.dataset\n        var before = dataset.before\n        var after = dataset.after\n        var url = dataset.url\n        var ctx = this\n        try {\n          if (ctx && before && ctx[before]) ctx[before].call(ctx, e)\n        } finally {\n          if (!url) return\n          _route(url)\n          if (ctx && after && ctx[after]) ctx[after].call(ctx, e)\n        }\n      }\n    }\n\n    function back(delta) {\n      wx.navigateBack({\n        delta: delta || 1\n      })\n    }\n    function preload(url) {\n      var name = getPageName(url)\n      name && dispatcher && dispatcher.emit('preload:' + name, url, fns.queryParse(url.split('?')[1]))\n    }\n    function getPage() {\n      return getCurrentPages().slice(0).pop()\n    }\n    function getPageName(url) {\n      var m = /^[\\w\\-]+(?=\\?|$)/.exec(url)\n      return m ? m[0] : conf.get('nameResolve')(url)\n    }\n    function curPageName() {\n      var route = getPage().route\n      if (!route) return ''\n      return getPageName(route)\n    }\n    function put(key, value) {\n      channel[key] = value\n      return this\n    }\n    function take(key) {\n      var v = channel[key]\n      // 释放引用\n      channel[key] = null\n      return v\n    }\n\n\n    /***/\n}),\n/* 6 */\n/***/ (function (module, exports, __webpack_require__) {\n\n    \n\n\n    var fns = __webpack_require__(0)\n    var bridge = __webpack_require__(5)\n    var cache = __webpack_require__(1)\n    var conf = __webpack_require__(2)\n    var redirector = __webpack_require__(4)\n    var message = __webpack_require__(3)\n    var modules = {\n      fns, redirector, cache, message, dispatcher,\n      channel: bridge.channel\n    }\n    var dispatcher\n    /**\n     * Component constructor\n     */\n    var refs = {}\n    var cid = 0\n    function component(def) {\n      if (!def) {\n        console.error(`Illegal component options.`)\n        def = {}\n      }\n      // extend page config\n      var extendComponentBefore = conf.get('extendComponentBefore')\n      extendComponentBefore && extendComponentBefore(def, modules)\n\n      def.created = fns.wrapFun(def.created, function () {\n        bridge.methods(this, dispatcher)\n      })\n      def.attached = fns.wrapFun(def.attached, function () {\n        var id = ++cid\n        this.$id = id\n        refs[id] = this\n        this._$ref = this.properties.ref || this.properties._ref\n        this.triggerEvent('ing', {\n          id: this.$id,\n          type: 'attached'\n        })\n      })\n      def.detached = fns.wrapFun(def.detached, function () {\n        delete refs[this.$id]\n        var $refs = this.$parent && this.$parent.$refs\n        var refName = this._$ref\n        if (refName && $refs) {\n          delete $refs[refName]\n        }\n        this.$parent = null\n      })\n      def.properties = fns.extend({}, def.properties, {\n        'ref': {\n          type: String,\n          value: '',\n          observer: function (next) {\n            /**\n             * 支持动态 ref\n             */\n            if (this._$ref !== next) {\n              var $refs = this.$parent && this.$parent.$refs\n              if ($refs) {\n                let ref = $refs[this._$ref]\n                delete $refs[this._$ref]\n                this._$ref = next\n                if (ref && next) {\n                  $refs[next]\n                }\n              }\n            }\n          }\n        },\n      })\n      def.methods = fns.extend({}, def.methods, {\n        // 与旧的一致\n        $set: function () {\n          return this.setData.apply(this, arguments)\n        },\n        $data: function () {\n          return this.data\n        },\n        $emit: function () {\n          if (!dispatcher) return\n          return dispatcher.emit.apply(dispatcher, arguments)\n        },\n        $on: function () {\n          if (!dispatcher) return function () { }\n          return dispatcher.on.apply(dispatcher, arguments)\n        },\n        $off: function () {\n          if (!dispatcher) return\n          return dispatcher.off.apply(dispatcher, arguments)\n        },\n        $call: function (method) {\n          var args = [].slice.call(arguments, 1)\n          this.triggerEvent('ing', {\n            id: this.$id,\n            type: 'event:call',\n            method,\n            args\n          })\n        },\n        /**\n         * 由父组件调用\n         */\n        _$attached: function (parent) {\n          this.$root = parent.$root || parent\n          this.$parent = parent\n        },\n        $: bridge.mount\n      })\n      Component(def)\n    }\n    component.getRef = function (id) {\n      return refs[id]\n    }\n    bridge.ref(component.getRef)\n    component.dispatcher = function (d) {\n      dispatcher = d\n    }\n    Component.C = component\n    module.exports = component\n\n\n    /***/\n}),\n/* 7 */\n/***/ (function (module, exports, __webpack_require__) {\n\n    \n\n\n    var fns = __webpack_require__(0)\n    var message = __webpack_require__(3)\n    var redirector = __webpack_require__(4)\n    var cache = __webpack_require__(1)\n    var C = __webpack_require__(6)\n    var bridge = __webpack_require__(5)\n    var _conf = __webpack_require__(2)\n    var dispatcher = new message()\n    var hasPageLoaded = 0\n    var isAppLaunched = 0\n    var isAppShowed = 0\n    var hideTime = 0\n    var modules = {\n      fns, redirector, cache, message, dispatcher,\n      channel: bridge.channel\n    }\n    bridge.ref(C.getRef)\n    bridge.dispatcher(dispatcher)\n    C.dispatcher(dispatcher)\n    function WXPage(name, option) {\n      if (fns.type(name) == 'object') {\n        option = name\n        name = option.name || '_unknow'\n      }\n      // page internal message\n      var emitter = new message()\n\n      // extend page config\n      var extendPageBefore = _conf.get('extendPageBefore')\n      extendPageBefore && extendPageBefore(name, option, modules)\n\n      // mixin component defs\n      // C.use(option, option.comps, `Page[${name}]`, emitter)\n      if (option.onNavigate) {\n        let onNavigateHandler = function (url, query) {\n          option.onNavigate({ url, query })\n        }\n        console.log(`Page[${name}] define \"onNavigate\".`)\n        dispatcher.on('navigateTo:' + name, onNavigateHandler)\n        dispatcher.on('redirectTo:' + name, onNavigateHandler)\n        dispatcher.on('switchTab:' + name, onNavigateHandler)\n        dispatcher.on('reLaunch:' + name, onNavigateHandler)\n      }\n      /**\n       * Preload lifecycle method\n       */\n      if (option.onPreload) {\n        console.log(`Page[${name}] define \"onPreload\".`)\n        dispatcher.on('preload:' + name, function (url, query) {\n          option.onPreload({ url, query })\n        })\n      }\n      /**\n       * Instance props\n       */\n      option.$state = {\n        // 是否小程序被打开首页启动页面\n        firstOpen: false\n      }\n      option.$emitter = emitter\n      bridge.methods(option)\n\n      /**\n       * Cross pages message methods\n       */\n      option.$on = function () {\n        return dispatcher.on.apply(dispatcher, arguments)\n      }\n      option.$emit = function () {\n        return dispatcher.emit.apply(dispatcher, arguments)\n      }\n      option.$off = function () {\n        return dispatcher.off.apply(dispatcher, arguments)\n      }\n      /**\n       * 父子通信枢纽模块\n       */\n      option.$ = bridge.mount\n      /**\n       * setData wrapper, for component setData with prefix\n       * @param {String} prefix prefix of component's data\n       * @param {Object} data\n       */\n      option.$setData = function (prefix, data) {\n        if (fns.type(prefix) == 'string') {\n          var props = {}\n          fns.objEach(data, function (k, v) {\n            props[prefix + '.' + k] = v\n          })\n          return this.setData(props)\n        } else if (fns.type(prefix) == 'object') {\n          return this.setData(prefix)\n        }\n      }\n      /**\n       * AOP life-cycle methods hook\n       */\n      option.onLoad = fns.wrapFun(option.onLoad, function () {\n        // After onLoad, onAwake is valid if defined\n        option.onAwake && message.on('app:sleep', (t) => {\n          option.onAwake.call(this, t)\n        })\n        if (!hasPageLoaded) {\n          hasPageLoaded = true\n\n          let $state = this.$state\n          $state.firstOpen = true\n        }\n      })\n      option.onReady = fns.wrapFun(option.onReady, function () {\n        redirector.emit('page:ready')\n      })\n\n      // call on launch\n      if (option.onPageLaunch) {\n        option.onPageLaunch()\n      }\n      if (option.onAppLaunch) {\n        isAppLaunched ? option.onAppLaunch.apply(option, isAppLaunched) : dispatcher.on('app:launch', function (args) {\n          option.onAppLaunch.apply(option, args)\n        })\n      }\n      if (option.onAppShow) {\n        isAppLaunched ? option.onAppShow.apply(option, isAppLaunched) : dispatcher.on('app:show', function (args) {\n          option.onAppShow.apply(option, args)\n        })\n      }\n\n      // extend page config\n      var extendPageAfter = _conf.get('extendPageAfter')\n      extendPageAfter && extendPageAfter(name, option, modules)\n      // register page\n      Page(option)\n      return option;\n    }\n    /**\n     * 由重定向模块转发到页面内派发器\n     */\n    bridge.redirectDelegate(redirector, dispatcher)\n    /**\n     * Application wrapper\n     */\n    function Application(option) {\n\n      if (!option.config || !option.config.route || !option.config.route.length) {\n        throw new Error('config.route is necessary !')\n      }\n      if (option.config) {\n        WXPage.config(option.config)\n      }\n      var ctx = option\n      /**\n       * APP sleep logical\n       */\n      option.onShow = option.onShow ? fns.wrapFun(option.onShow, appShowHandler) : appShowHandler\n      option.onHide = option.onHide ? fns.wrapFun(option.onHide, appHideHandler) : appHideHandler\n      option.onLaunch = option.onLaunch ? fns.wrapFun(option.onLaunch, appLaunchHandler) : appLaunchHandler\n      option.onLaunch = fns.wrapFun(option.onLaunch, function () {\n        ctx = this\n      })\n      if (option.onAwake) {\n        message.on('app:sleep', function (t) {\n          option.onAwake.call(ctx, t)\n        })\n      }\n      /**\n       * Use app config\n       */\n      App(option)\n    }\n    function appLaunchHandler() {\n      isAppLaunched = [].slice.call(arguments)\n      message.emit('app:launch', isAppLaunched)\n    }\n    function appShowHandler() {\n      try {\n        if (!isAppShowed) {\n          // call onAppShow only once\n          isAppShowed = [].slice.call(arguments)\n          message.emit('app:show', isAppShowed)\n        }\n      } finally {\n        if (!hideTime) return\n        var t = hideTime\n        hideTime = 0\n        message.emit('app:sleep', new Date() - t)\n      }\n    }\n    function appHideHandler() {\n      hideTime = new Date()\n    }\n\n    Page.P = WXPage\n    Page.C = Component.C = WXPage.C = WXPage.Comp = WXPage.Component = C\n    Page.A = App.A = WXPage.A = WXPage.App = WXPage.Application = Application\n    WXPage.redirector = redirector\n    WXPage.message = message\n    WXPage.cache = cache\n    WXPage.fns = fns\n    WXPage.getPageName = bridge.getPageName\n\n    /**\n     * Config handler\n     */\n\n    WXPage.config = function (key, value) {\n      if (fns.type(key) == 'object') {\n        fns.objEach(key, function (k, v) {\n          _conf.set(k, v)\n        })\n      } else {\n        _conf.set(key, value)\n      }\n      return this\n    }\n    message.assign(WXPage)\n    message.assign(C)\n    message.assign(Application)\n    module.exports = WXPage\n\n\n    /***/\n})\n/******/]);\n"]}