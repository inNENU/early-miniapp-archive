import * as ESTree from 'estree';
import { Value } from '../value';
import Signal from '../signal';
import Environment from '../environment';
export declare function Identifier(env: Environment<ESTree.Identifier>): any;
export declare function Literal(env: Environment<ESTree.Literal>): string | number | boolean | RegExp | null | undefined;
export declare function Program(env: Environment<ESTree.Program>): void;
export declare function ExpressionStatement(env: Environment<ESTree.ExpressionStatement>): any;
export declare function BlockStatement(env: Environment<ESTree.BlockStatement>): Signal | undefined;
export declare function EmptyStatement(env: Environment<ESTree.EmptyStatement>): void;
export declare function DebuggerStatement(env: Environment<ESTree.DebuggerStatement>): void;
export declare function WithStatement(env: Environment<ESTree.WithStatement>): void;
export declare function ReturnStatement(env: Environment<ESTree.ReturnStatement>): Signal;
export declare function LabeledStatement(env: Environment<ESTree.LabeledStatement>): any;
export declare function BreakStatement(env: Environment<ESTree.BreakStatement>): Signal;
export declare function ContinueStatement(env: Environment<ESTree.ContinueStatement>): Signal;
export declare function IfStatement(env: Environment<ESTree.IfStatement>): any;
export declare function SwitchStatement(env: Environment<ESTree.SwitchStatement>): Signal | undefined;
export declare function SwitchCase(env: Environment<ESTree.SwitchCase>): Signal | undefined;
export declare function ThrowStatement(env: Environment<ESTree.ThrowStatement>): void;
export declare function TryStatement(env: Environment<ESTree.TryStatement>): any;
export declare function CatchClause(env: Environment<ESTree.CatchClause>): any;
export declare function WhileStatement(env: Environment<ESTree.WhileStatement>): Signal | undefined;
export declare function DoWhileStatement(env: Environment<ESTree.DoWhileStatement>): Signal | undefined;
export declare function ForStatement(env: Environment<ESTree.ForStatement>): Signal | undefined;
export declare function ForInStatement(env: Environment<ESTree.ForInStatement>): Signal | undefined;
export declare function FunctionDeclaration(env: Environment<ESTree.FunctionDeclaration>): (this: any) => any;
export declare function VariableDeclaration(env: Environment<ESTree.VariableDeclaration>): void;
export declare function VariableDeclarator(env: Environment<ESTree.VariableDeclarator>): void;
export declare function ThisExpression(env: Environment<ESTree.ThisExpression>): any;
export declare function ArrayExpression(env: Environment<ESTree.ArrayExpression>): any[];
export declare function ObjectExpression(env: Environment<ESTree.ObjectExpression>): {
    [key: string]: any;
};
export declare function Property(env: Environment<ESTree.Property>): void;
export declare function FunctionExpression(env: Environment<ESTree.FunctionExpression>): (this: any) => any;
export declare function UnaryExpression(env: Environment<ESTree.UnaryExpression>): number | boolean | "string" | "number" | "boolean" | "symbol" | "undefined" | "object" | "function" | undefined;
export declare function UpdateExpression(env: Environment<ESTree.UpdateExpression>): number;
export declare const BinaryExpressionOperatorEvaluateMap: {
    '==': (a: any, b: any) => boolean;
    '!=': (a: any, b: any) => boolean;
    '===': (a: any, b: any) => boolean;
    '!==': (a: any, b: any) => boolean;
    '<': (a: any, b: any) => boolean;
    '<=': (a: any, b: any) => boolean;
    '>': (a: any, b: any) => boolean;
    '>=': (a: any, b: any) => boolean;
    '<<': (a: any, b: any) => number;
    '>>': (a: any, b: any) => number;
    '>>>': (a: any, b: any) => number;
    '+': (a: any, b: any) => any;
    '-': (a: any, b: any) => number;
    '*': (a: any, b: any) => number;
    '/': (a: any, b: any) => number;
    '%': (a: any, b: any) => number;
    '**': (a: any, b: any) => never;
    '|': (a: any, b: any) => number;
    '^': (a: any, b: any) => number;
    '&': (a: any, b: any) => number;
    'in': (a: any, b: any) => boolean;
    'instanceof': (a: any, b: any) => boolean;
};
export declare function BinaryExpression(env: Environment<ESTree.BinaryExpression>): any;
export declare const AssignmentExpressionOperatorEvaluateMap: {
    '=': (value: Value, v: any) => any;
    '+=': (value: Value, v: any) => any;
    '-=': (value: Value, v: any) => number;
    '*=': (value: Value, v: any) => number;
    '/=': (value: Value, v: any) => number;
    '%=': (value: Value, v: any) => number;
    '**=': (value: Value, v: any) => never;
    '<<=': (value: Value, v: any) => number;
    '>>=': (value: Value, v: any) => number;
    '>>>=': (value: Value, v: any) => number;
    '|=': (value: Value, v: any) => number;
    '^=': (value: Value, v: any) => number;
    '&=': (value: Value, v: any) => number;
};
export declare function AssignmentExpression(env: Environment<ESTree.AssignmentExpression>): any;
export declare function LogicalExpression(env: Environment<ESTree.LogicalExpression>): any;
export declare function MemberExpression(env: Environment<ESTree.MemberExpression>): any;
export declare function ConditionalExpression(env: Environment<ESTree.ConditionalExpression>): any;
export declare function CallExpression(env: Environment<ESTree.CallExpression>): any;
export declare function NewExpression(env: Environment<ESTree.NewExpression>): any;
export declare function SequenceExpression(env: Environment<ESTree.SequenceExpression>): any;
export declare function getPropertyName(node: ESTree.MemberExpression, ctx: Environment<ESTree.Node>): string;
export declare function getIdentifierOrMemberExpressionValue(node: ESTree.Pattern | ESTree.Expression, env: Environment<ESTree.Node>, assignment?: boolean): Value;
