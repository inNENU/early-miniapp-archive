"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const value_1 = require("../value");
const signal_1 = __importDefault(require("../signal"));
function Identifier(env) {
    if (env.node.name === 'undefined') {
        return undefined;
    }
    return env.scope.get(env.node.name).v;
}
exports.Identifier = Identifier;
function Literal(env) {
    return env.node.value;
}
exports.Literal = Literal;
function Program(env) {
    for (const node of env.node.body) {
        env.evaluate(node);
    }
}
exports.Program = Program;
function ExpressionStatement(env) {
    return env.evaluate(env.node.expression);
}
exports.ExpressionStatement = ExpressionStatement;
function BlockStatement(env) {
    let scope;
    if (!env.scope.invasive) {
        scope = env.createBlockScope();
    }
    else {
        scope = env.scope;
        scope.invasive = false;
    }
    for (const node of env.node.body) {
        if (node.type === 'FunctionDeclaration') {
            env.evaluate(node, { scope });
        }
        else if (node.type === 'VariableDeclaration' && node.kind === 'var') {
            for (const declarator of node.declarations) {
                scope.varDeclare(declarator.id.name);
            }
        }
    }
    for (const node of env.node.body) {
        if (node.type === 'FunctionDeclaration') {
            continue;
        }
        const signal = env.evaluate(node, { scope });
        if (signal_1.default.isSignal(signal)) {
            return signal;
        }
    }
}
exports.BlockStatement = BlockStatement;
function EmptyStatement(env) { }
exports.EmptyStatement = EmptyStatement;
function DebuggerStatement(env) {
    debugger;
}
exports.DebuggerStatement = DebuggerStatement;
function WithStatement(env) {
    throw new Error(`evil-eval: "${env.node.type}" not implemented`);
}
exports.WithStatement = WithStatement;
function ReturnStatement(env) {
    let value;
    if (env.node.argument) {
        value = env.evaluate(env.node.argument);
    }
    return signal_1.default.Return(value);
}
exports.ReturnStatement = ReturnStatement;
function LabeledStatement(env) {
    return env.evaluate(env.node.body, { label: env.node.label.name });
}
exports.LabeledStatement = LabeledStatement;
function BreakStatement(env) {
    let label;
    if (env.node.label) {
        label = env.node.label.name;
    }
    return signal_1.default.Break(label);
}
exports.BreakStatement = BreakStatement;
function ContinueStatement(env) {
    let label;
    if (env.node.label) {
        label = env.node.label.name;
    }
    return signal_1.default.Continue(label);
}
exports.ContinueStatement = ContinueStatement;
function IfStatement(env) {
    if (env.evaluate(env.node.test)) {
        return env.evaluate(env.node.consequent);
    }
    else if (env.node.alternate) {
        return env.evaluate(env.node.alternate);
    }
}
exports.IfStatement = IfStatement;
function SwitchStatement(env) {
    const discriminant = env.evaluate(env.node.discriminant);
    let matched = false;
    for (const case_ of env.node.cases) {
        if (!matched && (!case_.test || discriminant === env.evaluate(case_.test))) {
            matched = true;
        }
        if (matched) {
            const signal = env.evaluate(case_);
            if (signal_1.default.isBreak(signal)) {
                break;
            }
            else if (signal_1.default.isContinue(signal)) {
                continue;
            }
            else if (signal_1.default.isReturn(signal)) {
                return signal;
            }
        }
    }
}
exports.SwitchStatement = SwitchStatement;
function SwitchCase(env) {
    for (const node of env.node.consequent) {
        const signal = env.evaluate(node);
        if (signal_1.default.isSignal(signal)) {
            return signal;
        }
    }
}
exports.SwitchCase = SwitchCase;
function ThrowStatement(env) {
    throw env.evaluate(env.node.argument);
}
exports.ThrowStatement = ThrowStatement;
function TryStatement(env) {
    const { block, handler, finalizer } = env.node;
    try {
        return env.evaluate(block);
    }
    catch (err) {
        if (handler) {
            const param = handler.param;
            const scope = env.createBlockScope(true);
            scope.letDeclare(param.name, err);
            return env.evaluate(handler, { scope });
        }
        throw err;
    }
    finally {
        if (finalizer) {
            return env.evaluate(finalizer);
        }
    }
}
exports.TryStatement = TryStatement;
function CatchClause(env) {
    return env.evaluate(env.node.body);
}
exports.CatchClause = CatchClause;
function WhileStatement(env) {
    while (env.evaluate(env.node.test)) {
        const signal = env.evaluate(env.node.body);
        if (signal_1.default.isSignal(signal)) {
            if (signal_1.default.isBreak(signal)) {
                if (!signal.value || signal.value === env.label)
                    break;
            }
            else if (signal_1.default.isContinue(signal)) {
                if (!signal.value || signal.value === env.label)
                    continue;
            }
            return signal;
        }
    }
}
exports.WhileStatement = WhileStatement;
function DoWhileStatement(env) {
    do {
        const signal = env.evaluate(env.node.body);
        if (signal_1.default.isSignal(signal)) {
            if (signal_1.default.isBreak(signal)) {
                if (!signal.value || signal.value === env.label)
                    break;
            }
            else if (signal_1.default.isContinue(signal)) {
                if (!signal.value || signal.value === env.label)
                    continue;
            }
            return signal;
        }
    } while (env.evaluate(env.node.test));
}
exports.DoWhileStatement = DoWhileStatement;
function ForStatement(env) {
    const node = env.node;
    let scope = env.scope;
    if (node.init && node.init.type === 'VariableDeclaration') {
        scope = env.createBlockScope();
    }
    for (node.init && env.evaluate(node.init, { scope }); node.test ? env.evaluate(node.test, { scope }) : true; node.update && env.evaluate(node.update, { scope })) {
        const signal = env.evaluate(node.body, { scope });
        if (signal_1.default.isSignal(signal)) {
            if (signal_1.default.isBreak(signal)) {
                if (!signal.value || signal.value === env.label)
                    break;
            }
            else if (signal_1.default.isContinue(signal)) {
                if (!signal.value || signal.value === env.label)
                    continue;
            }
            return signal;
        }
    }
}
exports.ForStatement = ForStatement;
function ForInStatement(env) {
    const { left, right, body } = env.node;
    let scope = env.scope;
    let value;
    if (left.type === 'VariableDeclaration') {
        const id = left.declarations[0].id;
        value = scope.declare(id.name, undefined, left.kind);
    }
    else if (left.type === 'Identifier') {
        value = scope.get(left.name, true);
    }
    else {
        throw new Error(`evil-eval: [ForInStatement] Unsupported left type "${left.type}"`);
    }
    for (const key in env.evaluate(right)) {
        value.v = key;
        const signal = env.evaluate(body, { scope });
        if (signal_1.default.isSignal(signal)) {
            if (signal_1.default.isBreak(signal)) {
                if (!signal.value || signal.value === env.label)
                    break;
            }
            else if (signal_1.default.isContinue(signal)) {
                if (!signal.value || signal.value === env.label)
                    continue;
            }
            return signal;
        }
    }
}
exports.ForInStatement = ForInStatement;
function FunctionDeclaration(env) {
    const fn = FunctionExpression(env);
    env.scope.varDeclare(env.node.id.name, fn);
    return fn;
}
exports.FunctionDeclaration = FunctionDeclaration;
function VariableDeclaration(env) {
    for (const declarator of env.node.declarations) {
        const { name } = declarator.id;
        const value = declarator.init ? env.evaluate(declarator.init) : undefined;
        env.scope.declare(name, value);
    }
}
exports.VariableDeclaration = VariableDeclaration;
function VariableDeclarator(env) {
    throw new Error(`evil-eval: [VariableDeclarator] Should not happen`);
}
exports.VariableDeclarator = VariableDeclarator;
function ThisExpression(env) {
    const thisValue = env.scope.get('this');
    return thisValue ? thisValue.v : null;
}
exports.ThisExpression = ThisExpression;
function ArrayExpression(env) {
    return env.node.elements.map(it => env.evaluate(it));
}
exports.ArrayExpression = ArrayExpression;
function ObjectExpression(env) {
    const obj = {};
    for (const property of env.node.properties) {
        let key;
        if (property.key.type === 'Literal') {
            key = property.key.value;
        }
        else if (property.key.type === 'Identifier') {
            key = property.key.name;
        }
        else {
            throw new Error(`evil-eval: [ObjectExpression] Unsupported property key type "${property.key.type}"`);
        }
        obj[key] = env.evaluate(property.value);
    }
    return obj;
}
exports.ObjectExpression = ObjectExpression;
function Property(env) {
    throw new Error(`evil-eval: [Property] Should not happen`);
}
exports.Property = Property;
function FunctionExpression(env) {
    const node = env.node;
    const fn = function () {
        const scope = env.createFunctionScope(true);
        scope.constDeclare('this', this);
        scope.constDeclare('arguments', arguments);
        for (let i = 0, l = node.params.length; i < l; i++) {
            const { name } = node.params[i];
            scope.varDeclare(name, arguments[i]);
        }
        const signal = env.evaluate(node.body, { scope });
        if (signal_1.default.isReturn(signal)) {
            return signal.value;
        }
    };
    Object.defineProperties(fn, {
        name: { value: node.id ? node.id.name : '' },
        length: { value: node.params.length }
    });
    return fn;
}
exports.FunctionExpression = FunctionExpression;
const UnaryExpressionOperatorEvaluateMap = {
    '-': (env) => -env.evaluate(env.node.argument),
    '+': (env) => +env.evaluate(env.node.argument),
    '!': (env) => !env.evaluate(env.node.argument),
    '~': (env) => ~env.evaluate(env.node.argument),
    'typeof': (env) => {
        if (env.node.argument.type === 'Identifier') {
            try {
                const value = env.scope.get(env.node.argument.name);
                return value ? typeof value.v : 'undefined';
            }
            catch (err) {
                if (err.message === `${env.node.argument.name} is not defined`) {
                    return 'undefined';
                }
                else {
                    throw err;
                }
            }
        }
        else {
            return typeof env.evaluate(env.node.argument);
        }
    },
    'void': (env) => void env.evaluate(env.node.argument),
    'delete': (env) => {
        const argument = env.node.argument;
        if (argument.type === 'MemberExpression') {
            const obj = env.evaluate(argument.object);
            const name = getPropertyName(argument, env);
            return delete obj[name];
        }
        else if (argument.type === 'Identifier') {
            return false;
        }
        else if (argument.type === 'Literal') {
            return true;
        }
    }
};
function UnaryExpression(env) {
    return UnaryExpressionOperatorEvaluateMap[env.node.operator](env);
}
exports.UnaryExpression = UnaryExpression;
const UpdateExpressionOperatorEvaluateMap = {
    '++': (value, prefix) => prefix ? ++value.v : value.v++,
    '--': (value, prefix) => prefix ? --value.v : value.v--
};
function UpdateExpression(env) {
    const value = getIdentifierOrMemberExpressionValue(env.node.argument, env);
    return UpdateExpressionOperatorEvaluateMap[env.node.operator](value, env.node.prefix);
}
exports.UpdateExpression = UpdateExpression;
exports.BinaryExpressionOperatorEvaluateMap = {
    '==': (a, b) => a == b,
    '!=': (a, b) => a != b,
    '===': (a, b) => a === b,
    '!==': (a, b) => a !== b,
    '<': (a, b) => a < b,
    '<=': (a, b) => a <= b,
    '>': (a, b) => a > b,
    '>=': (a, b) => a >= b,
    '<<': (a, b) => a << b,
    '>>': (a, b) => a >> b,
    '>>>': (a, b) => a >>> b,
    '+': (a, b) => a + b,
    '-': (a, b) => a - b,
    '*': (a, b) => a * b,
    '/': (a, b) => a / b,
    '%': (a, b) => a % b,
    '**': (a, b) => { throw new Error('evil-eval: es5 not support operator "**"'); },
    '|': (a, b) => a | b,
    '^': (a, b) => a ^ b,
    '&': (a, b) => a & b,
    'in': (a, b) => a in b,
    'instanceof': (a, b) => a instanceof b
};
function BinaryExpression(env) {
    const a = env.evaluate(env.node.left);
    const b = env.evaluate(env.node.right);
    return exports.BinaryExpressionOperatorEvaluateMap[env.node.operator](a, b);
}
exports.BinaryExpression = BinaryExpression;
exports.AssignmentExpressionOperatorEvaluateMap = {
    '=': (value, v) => value.v = v,
    '+=': (value, v) => value.v += v,
    '-=': (value, v) => value.v -= v,
    '*=': (value, v) => value.v *= v,
    '/=': (value, v) => value.v /= v,
    '%=': (value, v) => value.v %= v,
    '**=': (value, v) => { throw new Error('evil-eval: es5 not support operator "**='); },
    '<<=': (value, v) => value.v <<= v,
    '>>=': (value, v) => value.v >>= v,
    '>>>=': (value, v) => value.v >>>= v,
    '|=': (value, v) => value.v |= v,
    '^=': (value, v) => value.v ^= v,
    '&=': (value, v) => value.v &= v
};
function AssignmentExpression(env) {
    const node = env.node;
    const value = getIdentifierOrMemberExpressionValue(node.left, env, node.operator === '=');
    return exports.AssignmentExpressionOperatorEvaluateMap[node.operator](value, env.evaluate(node.right));
}
exports.AssignmentExpression = AssignmentExpression;
const LogicalExpressionOperatorEvaluateMap = {
    '||': (a, b) => a || b,
    '&&': (a, b) => a && b
};
function LogicalExpression(env) {
    const a = env.evaluate(env.node.left);
    const b = env.evaluate(env.node.right);
    return LogicalExpressionOperatorEvaluateMap[env.node.operator](a, b);
}
exports.LogicalExpression = LogicalExpression;
function MemberExpression(env) {
    const obj = env.evaluate(env.node.object);
    const name = getPropertyName(env.node, env);
    return obj[name];
}
exports.MemberExpression = MemberExpression;
function ConditionalExpression(env) {
    return env.evaluate(env.node.test)
        ? env.evaluate(env.node.consequent)
        : env.evaluate(env.node.alternate);
}
exports.ConditionalExpression = ConditionalExpression;
function CallExpression(env) {
    const fn = env.evaluate(env.node.callee);
    const args = env.node.arguments.map(it => env.evaluate(it));
    let thisValue;
    if (env.node.callee.type == 'MemberExpression') {
        thisValue = env.evaluate(env.node.callee.object);
    }
    return fn.apply(thisValue, args);
}
exports.CallExpression = CallExpression;
function NewExpression(env) {
    const fn = env.evaluate(env.node.callee);
    const args = env.node.arguments.map(arg => env.evaluate(arg));
    return new (fn.bind.apply(fn, [null].concat(args)));
}
exports.NewExpression = NewExpression;
function SequenceExpression(env) {
    let last;
    for (const expression of env.node.expressions) {
        last = env.evaluate(expression);
    }
    return last;
}
exports.SequenceExpression = SequenceExpression;
// -- private --
function getPropertyName(node, ctx) {
    if (node.computed) {
        return ctx.evaluate(node.property);
    }
    else {
        return node.property.name;
    }
}
exports.getPropertyName = getPropertyName;
function getIdentifierOrMemberExpressionValue(node, env, assignment = false) {
    if (node.type === 'Identifier') {
        return env.scope.get(node.name, assignment);
    }
    else if (node.type === 'MemberExpression') {
        const obj = env.evaluate(node.object);
        const name = getPropertyName(node, env);
        return value_1.createMemberValue(obj, name);
    }
    else {
        throw new Error(`evil-eval: Not support to get value of node type "${node.type}"`);
    }
}
exports.getIdentifierOrMemberExpressionValue = getIdentifierOrMemberExpressionValue;
//# sourceMappingURL=es5.js.map