"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const signal_1 = __importDefault(require("../signal"));
const tool_1 = require("../tool");
function ExpressionStatement(env) {
    return env.evaluate(env.node.expression, { extra: env.extra });
}
exports.ExpressionStatement = ExpressionStatement;
function BlockStatement(env) {
    let scope;
    if (!env.scope.invasive) {
        scope = env.createBlockScope();
    }
    else {
        scope = env.scope;
        scope.invasive = false;
    }
    for (const node of env.node.body) {
        if (node.type === 'FunctionDeclaration') {
            env.evaluate(node, { scope });
        }
        else if (node.type === 'VariableDeclaration' && node.kind === 'var') {
            for (const declarator of node.declarations) {
                scope.varDeclare(declarator.id.name);
            }
        }
    }
    for (const node of env.node.body) {
        if (node.type === 'FunctionDeclaration') {
            continue;
        }
        const signal = env.evaluate(node, { scope, extra: env.extra });
        if (signal_1.default.isSignal(signal)) {
            return signal;
        }
    }
}
exports.BlockStatement = BlockStatement;
function VariableDeclaration(env) {
    for (const declarator of env.node.declarations) {
        const v = declarator.init ? env.evaluate(declarator.init) : undefined;
        declarePatternValue({ node: declarator.id, v, env, scope: env.scope, kind: env.node.kind });
    }
}
exports.VariableDeclaration = VariableDeclaration;
function ArrayExpression(env) {
    let arr = [];
    for (let element of env.node.elements) {
        if (element.type !== 'SpreadElement') {
            arr.push(env.evaluate(element));
        }
        else {
            arr = [...arr, ...env.evaluate(element.argument)];
        }
    }
    return arr;
}
exports.ArrayExpression = ArrayExpression;
function ObjectExpression(env) {
    const obj = {};
    for (const prop of env.node.properties) {
        let key;
        if (!prop.computed) {
            if (prop.key.type === 'Identifier') {
                key = prop.key.name;
            }
            else {
                key = prop.key.value;
            }
        }
        else {
            if (prop.key.type === 'Identifier') {
                const value = env.scope.get(prop.key.name);
                key = value.v;
            }
            else {
                key = env.evaluate(prop.key);
            }
        }
        const value = env.evaluate(prop.value);
        if (prop.kind === 'init') {
            obj[key] = value;
        }
        else if (prop.kind === 'get') {
            Object.defineProperty(obj, key, { get: value });
        }
        else if (prop.kind === 'set') {
            Object.defineProperty(obj, key, { set: value });
        }
        else {
            throw new Error(`evil-eval: [ObjectExpression] Unsupported property kind "${prop.kind}"`);
        }
    }
    return obj;
}
exports.ObjectExpression = ObjectExpression;
function FunctionExpression(env) {
    const node = env.node;
    const fn = function () {
        const scope = env.createFunctionScope(true);
        scope.constDeclare('this', this);
        scope.constDeclare('arguments', arguments);
        if (env.extra && env.extra.SuperClass) {
            if (env.extra.isConstructor || env.extra.isStaticMethod) {
                scope.constDeclare('@@evil-eval/super', env.extra.SuperClass);
            }
            else if (env.extra.isMethod) {
                scope.constDeclare('@@evil-eval/super', env.extra.SuperClass.prototype);
            }
        }
        for (let i = 0, l = node.params.length; i < l; i++) {
            const { name } = node.params[i];
            scope.varDeclare(name, arguments[i]);
        }
        const signal = env.evaluate(node.body, { scope, extra: env.extra });
        if (signal_1.default.isReturn(signal)) {
            return signal.value;
        }
    };
    Object.defineProperties(fn, {
        name: { value: node.id ? node.id.name : '' },
        length: { value: node.params.length }
    });
    return fn;
}
exports.FunctionExpression = FunctionExpression;
function CallExpression(env) {
    const fn = env.evaluate(env.node.callee);
    const args = env.node.arguments.map(it => env.evaluate(it));
    let thisValue;
    if (env.node.callee.type === 'MemberExpression') {
        if (env.node.callee.object.type !== 'Super') {
            thisValue = env.evaluate(env.node.callee.object);
        }
        else {
            const value = env.scope.get('this');
            thisValue = value.v;
        }
    }
    else if (env.extra && env.extra.isConstructor) {
        const value = env.scope.get('this');
        thisValue = value.v;
    }
    return fn.apply(thisValue, args);
}
exports.CallExpression = CallExpression;
// -- es2015 new feature --
function ForOfStatement(env) {
    const { left, right, body } = env.node;
    let scope = env.scope;
    for (const v of env.evaluate(right)) {
        if (left.type === 'VariableDeclaration') {
            if (left.kind === 'let' || left.kind === 'const') {
                scope = env.createBlockScope(true);
            }
            const id = left.declarations[0].id;
            // for (let it of list);
            // for (let { id } of list);
            declarePatternValue({ node: id, v, env, scope, kind: left.kind });
        }
        else {
            // for (it of list);
            // for ({ id } of list);
            declarePatternValue({ node: left, v, env, scope });
        }
        const signal = env.evaluate(body, { scope });
        if (signal_1.default.isSignal(signal)) {
            if (signal_1.default.isBreak(signal)) {
                if (!signal.value || signal.value === env.label)
                    break;
            }
            else if (signal_1.default.isContinue(signal)) {
                if (!signal.value || signal.value === env.label)
                    continue;
            }
            return signal;
        }
    }
}
exports.ForOfStatement = ForOfStatement;
function Super(env) {
    const value = env.scope.get('@@evil-eval/super');
    return value.v;
}
exports.Super = Super;
/**
 * see: ArrayExpression
 */
function SpreadElement(env) {
    throw new Error(`evil-eval: [SpreadElement] Should not happen`);
}
exports.SpreadElement = SpreadElement;
function ArrowFunctionExpression(env) {
    const node = env.node;
    const fn = function () {
        const scope = env.createFunctionScope(true);
        for (let i = 0, l = node.params.length; i < l; i++) {
            const { name } = node.params[i];
            scope.varDeclare(name, arguments[i]);
        }
        const signal = env.evaluate(node.body, { scope, extra: env.extra });
        if (signal_1.default.isReturn(signal)) {
            return signal.value;
        }
    };
    Object.defineProperties(fn, {
        length: { value: node.params.length }
    });
    return fn;
}
exports.ArrowFunctionExpression = ArrowFunctionExpression;
function YieldExpression(env) {
    throw new Error(`evil-eval: "${env.node.type}" not implemented`);
}
exports.YieldExpression = YieldExpression;
function TemplateLiteral(env) {
    throw new Error(`evil-eval: "${env.node.type}" not implemented`);
}
exports.TemplateLiteral = TemplateLiteral;
function TaggedTemplateExpression(env) {
    throw new Error(`evil-eval: "${env.node.type}" not implemented`);
}
exports.TaggedTemplateExpression = TaggedTemplateExpression;
function TemplateElement(env) {
    throw new Error(`evil-eval: "${env.node.type}" not implemented`);
}
exports.TemplateElement = TemplateElement;
function ObjectPattern(env) {
    throw new Error(`evil-eval: "${env.node.type}" not implemented`);
}
exports.ObjectPattern = ObjectPattern;
function ArrayPattern(env) {
    throw new Error(`evil-eval: "${env.node.type}" not implemented`);
}
exports.ArrayPattern = ArrayPattern;
function RestElement(env) {
    throw new Error(`evil-eval: "${env.node.type}" not implemented`);
}
exports.RestElement = RestElement;
function AssignmentPattern(env) {
    throw new Error(`evil-eval: "${env.node.type}" not implemented`);
}
exports.AssignmentPattern = AssignmentPattern;
function ClassBody(env) {
    const body = env.node.body;
    const ctor = body.find(n => n.kind === 'constructor');
    let Class;
    if (ctor) {
        Class = env.evaluate(ctor.value, { extra: Object.assign({}, env.extra, { isConstructor: true }) });
    }
    else {
        Class = function () { };
    }
    if (env.extra && env.extra.SuperClass) {
        extends_(Class, env.extra.SuperClass);
    }
    let staticProperties = {};
    let properties = {};
    for (const node of body) {
        let key = node.key.name;
        if (node.computed) {
            const value = env.scope.get(key);
            key = value.v;
        }
        let prop;
        if (node.kind === 'method') {
            if (!node.static) {
                prop = properties[key];
                if (!prop || !prop.value) {
                    prop = {
                        configurable: true,
                        enumerable: true
                    };
                }
                prop.value = env.evaluate(node.value, { extra: Object.assign({}, env.extra, { isMethod: true }) });
                properties[key] = prop;
            }
            else {
                prop = staticProperties[key];
                if (!prop || !prop.value) {
                    prop = {
                        configurable: true,
                        enumerable: true
                    };
                }
                prop.value = env.evaluate(node.value, { extra: Object.assign({}, env.extra, { isStaticMethod: true }) });
                staticProperties[key] = prop;
            }
        }
        else if (node.kind === 'get') {
            if (!node.static) {
                prop = properties[key];
                if (!prop || prop.value) {
                    prop = {
                        configurable: true,
                        enumerable: true
                    };
                }
                prop.get = env.evaluate(node.value);
                properties[key] = prop;
            }
            else {
                prop = staticProperties[key];
                if (!prop || prop.value) {
                    prop = {
                        configurable: true,
                        enumerable: true
                    };
                }
                prop.get = env.evaluate(node.value);
                staticProperties[key] = prop;
            }
        }
        else if (node.kind === 'set') {
            if (!node.static) {
                prop = properties[key];
                if (!prop || prop.value) {
                    prop = {
                        configurable: true,
                        enumerable: true
                    };
                }
                prop.set = env.evaluate(node.value);
                properties[key] = prop;
            }
            else {
                prop = staticProperties[key];
                if (!prop || prop.value) {
                    prop = {
                        configurable: true,
                        enumerable: true
                    };
                }
                prop.set = env.evaluate(node.value);
                staticProperties[key] = prop;
            }
        }
    }
    Object.defineProperties(Class, staticProperties);
    Object.defineProperties(Class.prototype, properties);
    return Class;
}
exports.ClassBody = ClassBody;
/**
 * see: ClassBody
 */
function MethodDefinition(env) {
    throw new Error(`evil-eval: [MethodDefinition] Should not happen`);
}
exports.MethodDefinition = MethodDefinition;
function ClassDeclaration(env) {
    const Class = ClassExpression(env);
    env.scope.constDeclare(env.node.id.name, Class);
    return Class;
}
exports.ClassDeclaration = ClassDeclaration;
function ClassExpression(env) {
    const { node } = env;
    let SuperClass;
    if (node.superClass) {
        SuperClass = env.evaluate(node.superClass);
    }
    const Class = env.evaluate(node.body, { extra: { SuperClass } });
    if (node.id) {
        Object.defineProperty(Class, 'name', { value: node.id.name });
    }
    return Class;
}
exports.ClassExpression = ClassExpression;
function MetaProperty(env) {
    throw new Error(`evil-eval: "${env.node.type}" not implemented`);
}
exports.MetaProperty = MetaProperty;
function ImportDeclaration(env) {
    throw new Error(`evil-eval: "${env.node.type}" not implemented`);
}
exports.ImportDeclaration = ImportDeclaration;
function ImportSpecifier(env) {
    throw new Error(`evil-eval: "${env.node.type}" not implemented`);
}
exports.ImportSpecifier = ImportSpecifier;
function ImportDefaultSpecifier(env) {
    throw new Error(`evil-eval: "${env.node.type}" not implemented`);
}
exports.ImportDefaultSpecifier = ImportDefaultSpecifier;
function ImportNamespaceSpecifier(env) {
    throw new Error(`evil-eval: "${env.node.type}" not implemented`);
}
exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
function ExportNamedDeclaration(env) {
    const { node, scope } = env;
    const exportsValue = scope.get('exports');
    if (node.declaration) {
        if (node.declaration.type === 'VariableDeclaration') {
            for (const declarator of node.declaration.declarations) {
                const v = env.evaluate(declarator.init);
                const declarationNames = [];
                declarePatternValue({ node: declarator.id, v, env, scope: env.scope, kind: node.declaration.kind, declarationNames });
                for (const name of declarationNames) {
                    exportsValue.v[name] = scope.get(name).v;
                }
            }
        }
        else {
            exportsValue.v[node.declaration.id.name] = env.evaluate(node.declaration);
        }
    }
    else {
        throw new Error(`evil-eval: "${env.node.type}" not implemented`);
    }
}
exports.ExportNamedDeclaration = ExportNamedDeclaration;
function ExportSpecifier(env) {
    throw new Error(`evil-eval: "${env.node.type}" not implemented`);
}
exports.ExportSpecifier = ExportSpecifier;
function ExportDefaultDeclaration(env) {
    const value = env.scope.get('exports');
    value.v.default = env.evaluate(env.node.declaration);
}
exports.ExportDefaultDeclaration = ExportDefaultDeclaration;
function ExportAllDeclaration(env) {
    throw new Error(`evil-eval: "${env.node.type}" not implemented`);
}
exports.ExportAllDeclaration = ExportAllDeclaration;
function declarePatternValue(options) {
    if (options.node.type === 'Identifier') {
        if (options.kind) {
            options.scope.declare(options.node.name, options.v, options.kind);
            options.declarationNames && options.declarationNames.push(options.node.name);
        }
        else {
            const value = options.scope.get(options.node.name, true);
            value.v = options.v;
        }
    }
    else if (options.node.type === 'ObjectPattern') {
        declareObjectPatternValue(options);
    }
    else if (options.node.type === 'ArrayPattern') {
        declareArrayPatternValue(options);
    }
    else {
        throw new Error(`evil-eval: Not support to declare pattern value of node type "${options.node.type}"`);
    }
}
function declareObjectPatternValue({ node, v: vObj, env, scope, kind, declarationNames }) {
    for (const prop of node.properties) {
        let key;
        if (!prop.computed) {
            if (prop.key.type === 'Identifier') {
                key = prop.key.name;
            }
            else {
                key = prop.key.value;
            }
        }
        else {
            key = env.evaluate(prop.key);
        }
        const v = vObj[key];
        if (prop.value.type === 'Identifier') {
            if (v === null || v === undefined) {
                throw new TypeError(`Cannot destructure property \`${key}\` of 'undefined' or 'null'.`);
            }
            if (kind) {
                scope.declare(prop.value.name, v, kind);
                declarationNames && declarationNames.push(prop.value.name);
            }
            else {
                const value = scope.get(prop.value.name, true);
                value.v = v;
            }
        }
        else {
            declarePatternValue({ node: prop.value, v, env, scope, kind, declarationNames });
        }
    }
}
function declareArrayPatternValue({ node, v: vArr, env, scope, kind, declarationNames }) {
    for (let i = 0, l = node.elements.length; i < l; i++) {
        const element = node.elements[i];
        let v = vArr[i];
        if (element.type === 'Identifier') {
            if (v === undefined) {
                throw new TypeError(`Cannot read property 'Symbol(Symbol.iterator)' of undefined`);
            }
            else if (v === null) {
                throw new TypeError(`Cannot read property 'Symbol(Symbol.iterator)' of object`);
            }
            if (kind) {
                scope.declare(element.name, v, kind);
                declarationNames && declarationNames.push(element.name);
            }
            else {
                const value = scope.get(element.name, true);
                value.v = v;
            }
        }
        else if (element.type === 'RestElement') {
            const name = element.argument.name;
            v = tool_1.slice.call(vArr, i);
            if (kind) {
                scope.declare(name, v, kind);
                declarationNames && declarationNames.push(name);
            }
            else {
                const value = scope.get(name, true);
                value.v = v;
            }
        }
        else {
            declarePatternValue({ node: element, v, env, scope, kind, declarationNames });
        }
    }
}
const extendStatics = Object.setPrototypeOf
    || ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; })
    || function (Class, SuperClass) { for (var p in SuperClass)
        if (SuperClass.hasOwnProperty(p))
            Class[p] = SuperClass[p]; };
function extends_(Class, SuperClass) {
    extendStatics(Class, SuperClass);
    function __() { this.constructor = Class; }
    Class.prototype = SuperClass === null
        ? Object.create(SuperClass)
        : (__.prototype = SuperClass.prototype, new __());
}
//# sourceMappingURL=es2015.js.map